{% extends 'layout.html' %}

{% block title %}Smart Runner - AI Fitness{% endblock %}

{% block sidebar %}{% endblock %}

{% block content %}
<!-- React Root (Replaces old static HTML) -->
<div id="react-root" class="h-100"></div>

<!-- Modal Video -->
<div class="modal fade" id="videoModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content bg-card text-theme border border-theme">
            <div class="modal-header border-theme">
                <h5 class="modal-title text-cyber-green">Video</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-0">
                <div class="ratio ratio-16x9">
                    <iframe id="videoFrame" src="" title="Video ejercicio"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
            </div>
            <div class="modal-footer border-theme">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
            </div>
        </div>
    </div>
</div>

<!-- STYLES -->
<style>
    /* Zero-Scroll Native Layout */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        background-color: var(--bg-body);
        color: var(--text-main);
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        height: 100vh;
        height: var(--app-height, 100dvh);
        width: 100vw;
        overflow: hidden;
        /* Prevent body scroll */
        overscroll-behavior: none;
        /* No bounce */
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
    }

    #react-root {
        height: 100%;
        width: 100%;
    }

    .main-content {
        margin: 0 !important;
        padding-top: 0 !important;
    }

    .main-content>main.container {
        max-width: 100% !important;
        padding: 0 !important;
    }

    /* Main Flex Container */
    .player-container {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--bg-body);
    }

    /* 1. HEADER (Fixed) */
    .header-section {
        flex: 0 0 auto;
        z-index: 10;
        background: var(--overlay-panel);
        backdrop-filter: blur(10px);
        padding: 0.5rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--border-color);
    }

    /* 2. VISUAL STAGE (Flexible) */
    .visual-stage {
        flex: 1 1 auto;
        position: relative;
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow-y: auto;
        /* Internal scroll if needed */
        overflow-x: hidden;
        perspective: 1000px;
        padding: 1rem;
    }

    /* 3. CONTROLS (Fixed Bottom) */
    .controls-section {
        flex: 0 0 auto;
        background: var(--bg-body);
        border-top: 1px solid var(--border-color);
        padding: 15px;
        padding-bottom: calc(15px + env(safe-area-inset-bottom));
        z-index: 20;
    }

    /* Component Styles */
    .active-card {
        width: 100%;
        max-width: 600px;
        background: var(--bg-card);
        border: 2px solid var(--border-color);
        border-radius: 24px;
        padding: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
    }

    .active-card.time-mode {
        border-color: #00ff9d;
        box-shadow: 0 0 20px rgba(0, 255, 157, 0.15);
    }

    /* Typography & Utilities */
    .text-cyber-green {
        color: #00ff9d !important;
    }

    .text-cyber-orange {
        color: #ff9d00 !important;
    }

    .input-hud {
        background: var(--bg-body);
        border: 1px solid var(--border-color);
        color: var(--text-main);
        font-family: 'Courier New', monospace;
        font-size: 2rem;
        text-align: center;
        border-radius: 12px;
        height: 60px;
    }

    .input-hud:focus {
        border-color: #00ff9d;
        outline: none;
        box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
    }

    .btn-action {
        background: #00E676;
        /* Vibrant Green */
        color: #000;
        font-weight: 800;
        text-transform: uppercase;
        border: none;
        border-radius: 50px;
        font-size: 1.1rem;
        letter-spacing: 1px;
        padding: 16px;
        width: 100%;
        box-shadow: 0 4px 15px rgba(0, 230, 118, 0.4);
        transition: transform 0.1s;
    }

    .btn-action:active {
        transform: scale(0.98);
    }

    /* Animations */
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animate-entry {
        animation: slideIn 0.3s ease-out forwards;
    }

    .animate-slide-up {
        animation: slideIn 0.4s ease-out forwards;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
    }

    .animate-fade-in {
        animation: fadeIn 0.3s ease-out forwards;
    }

    @media (max-width: 768px) {
        .player-container {
            /* Ensure full height usage */
        }

        .visual-stage {
            padding: 0.5rem;
            /* Reduced from 1rem */
            justify-content: flex-start;
            /* Align top on mobile to avoid centering issues if overflow */
            padding-top: 1rem;
        }

        .active-card {
            padding: 1rem;
            border-radius: 16px;
            max-width: 100%;
            border-width: 1px;
            /* Thinner border */
        }

        .heading-wrap {
            font-size: 1.5rem;
            /* Smaller title */
            line-height: 1.2;
            margin-bottom: 0.25rem !important;
        }

        .input-hud {
            font-size: 1.5rem;
            height: 48px;
            width: 80px !important;
            /* Fixed compact width */
        }

        .btn-control-hud {
            width: 40px !important;
            height: 40px !important;
        }

        .btn-action {
            padding: 12px;
            font-size: 1rem;
            letter-spacing: 0.5px;
        }

        /* Compact layout helpers */
        .mobile-compact-mb {
            margin-bottom: 0.5rem !important;
        }

        .mobile-hide {
            display: none !important;
        }

        .controls-section {
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }
    }

    .btn-control-hud {
        width: 44px;
        height: 44px;
    }

    .btn-rpe-hud {
        width: 50px;
        height: 40px;
    }

    .plate-icon-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 2px solid #00ff9d;
        /* Cyan highlight */
        background: var(--bg-input);
        /* Light background for contrast */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
    }

    .plate-icon-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
    }

    .plate-icon-img {
        width: 39px;
        height: 39px;
        object-fit: contain;
    }

    .weight-header {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 6px;
    }

    .reps-header {
        display: flex;
        flex-direction: column;
        align-items: center;
        /* justify-content: flex-end; -- Standard flex behavior (top) is fine for Reps unless forced */
        justify-content: center;
        gap: 6px;
        margin-bottom: 6px;
        /* Remove fixed height for Normal Mode to restore original behavior */
        min-height: auto;
    }

    /* Focus Mode Alignment */
    .focus-mode .reps-header {
        /* Match the height of the Weight Header (Label + Unit Button) in Focus Mode (~28-30px) */
        min-height: 28px;
        justify-content: flex-end;
    }

    .focus-mode .weight-header {
        justify-content: flex-end;
    }

    .tap-hint-overlay {
        position: absolute;
        inset: 0;
        border: 1px dashed rgba(0, 210, 255, 0.55);
        border-radius: 12px;
        background: rgba(13, 20, 30, 0.45);
        color: #e6f0ff;
        font-size: 0.7rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
    }

    .reps-column {
        /* Button (36px) + Gap (6px) = 42px exactly */
        padding-top: 42px;
    }

    /* Focus Mode overrides */
    .focus-mode .reps-column {
        padding-top: 0;
    }

    .focus-mode .reps-header {
        /* Match height of Weight Header (~28px with button) so inputs start at same line */
        min-height: 28px;
        justify-content: flex-end;
    }

    .focus-mode .weight-header {
        justify-content: flex-end;
        min-height: 28px;
        /* Force match */
    }

    .plate-modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2500;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
    }

    .plate-modal {
        background: var(--bg-body);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        width: min(420px, 95vw);
        color: var(--text-main);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.5);
    }

    .plate-modal-header,
    .plate-modal-footer {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .plate-modal-footer {
        border-top: 1px solid var(--border-color);
        border-bottom: none;
    }

    .plate-modal-body {
        padding: 12px 16px 4px;
    }

    .plate-mode-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 6px 0 12px;
    }

    .plate-mode-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.04em;
    }

    .plate-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
    }

    .plate-tile {
        background: var(--bg-card);
        /* Theme-aware background */
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 8px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .plate-tile img {
        width: 36px;
        height: 36px;
        object-fit: contain;
        margin-bottom: 4px;
    }

    .plate-tile:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        border-color: #00ff9d;
    }

    .plate-counter {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        margin-top: 6px;
    }

    .plate-counter button {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1px solid #dee2e6;
        background: #fff;
        color: #000;
        font-weight: bold;
    }

    .plate-total {
        font-size: 1.1rem;
        font-weight: 700;
    }

    .heading-wrap {
        white-space: normal;
        word-wrap: break-word;
        line-height: 1.1;
        font-size: clamp(1.5rem, 5vw, 2.5rem);
    }

    .pending-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 2100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
    }

    .pending-backdrop.show {
        opacity: 1;
        pointer-events: auto;
    }

    .pending-panel {
        position: fixed;
        top: 70px;
        right: 0;
        width: 320px;
        height: calc(100vh - 70px);
        background: var(--bg-body);
        border-left: 1px solid var(--border-color);
        z-index: 2200;
        transform: translateX(100%);
        transition: transform 0.25s ease;
        display: flex;
        flex-direction: column;
    }

    .pending-panel.open {
        transform: translateX(0);
    }

    .pending-panel-header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .pending-panel-body {
        padding: 12px 16px;
        overflow-y: auto;
        flex: 1;
    }

    .header-info {
        z-index: 1;
    }

    .header-controls {
        z-index: 2;
    }

    .header-timer {
        z-index: 1;
    }

    @media (max-width: 768px) {
        .header-section {
            position: relative;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .header-info {
            width: 100%;
            text-align: center;
        }

        .header-timer {
            position: static !important;
            transform: none !important;
            order: 2;
        }

        .header-controls {
            width: 100%;
            justify-content: center !important;
            order: 3;
        }

        .pending-panel {
            top: auto;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 60vh;
            border-left: none;
            border-top: 1px solid #222;
            transform: translateY(100%);
        }

        .pending-panel.open {
            transform: translateY(0);
        }

        .pending-panel.open {
            transform: translateY(0);
        }
    }

    /* Completion Icon Overlay */
    .completion-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
        backdrop-filter: blur(5px);
    }

    .completion-overlay.show {
        opacity: 1;
        pointer-events: auto;
    }

    .completion-icon {
        width: 300px;
        height: 300px;
        object-fit: contain;
        filter: drop-shadow(0 0 30px rgba(0, 255, 157, 0.6));
        animation: popIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes popIn {
        0% {
            transform: scale(0.5);
            opacity: 0;
        }

        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* Countdown Overlay */
    .countdown-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .countdown-overlay.show {
        opacity: 1;
        pointer-events: auto;
    }

    .countdown-image {
        width: 400px;
        height: 400px;
        object-fit: contain;
        margin-bottom: 2rem;
    }

    .countdown-text {
        font-family: 'Courier New', Courier, monospace;
        font-size: 5rem;
        font-weight: bold;
        color: #00ff9d;
        text-shadow: 0 0 20px rgba(0, 255, 157, 0.8), 0 0 40px rgba(0, 255, 157, 0.4);
        letter-spacing: 5px;
    }
</style>


<!-- DEPENDENCIES (CDN) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- REACT APP -->
<script type="text/javascript">
    function setAppHeight() {
        const doc = document.documentElement;
        doc.style.setProperty('--app-height', `${window.innerHeight}px`);
    }

    window.addEventListener('resize', setAppHeight);
    window.addEventListener('orientationchange', setAppHeight);
    setAppHeight();

    // Inject server-side data from Jinja OUTSIDE the raw block
    window.initialRoutine = {{ routine | tojson }};
    window.currentUserName = {{ current_user_name | default ('', true) | tojson }};
    window.currentUserId = {{ current_user_id | default ('', true) | tojson }};
    window.restoredState = {{ restored_state | tojson }};
</script>

{% raw %}
<script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback, createContext, useContext } = React;

    // --- MOCK DATA / INJECTED DATA ---
    const INITIAL_ROUTINE = window.initialRoutine;
    const CURRENT_USER_NAME = window.currentUserName;
    const CURRENT_USER_ID = window.currentUserId;
    const RESTORED_STATE = window.restoredState;

    // --- HELPERS ---
    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${m}:${s}`;
    };

    const getAudio = () => {
        return new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
    };

    const getReturnUrl = () => {
        const params = new URLSearchParams(window.location.search);
        // Default to home if no specific return_to is provided
        return params.get('return_to') || '/';
    };

    if (CURRENT_USER_ID) {
        try {
            localStorage.setItem("ai_fitness_uid", CURRENT_USER_ID);
        } catch (e) { }
    }

    const EQUIPMENT_MAP = {
        barbell: { label: "Barra", icon: "fas fa-grip-lines" },
        dumbbell: { label: "Mancuernas", icon: "fas fa-dumbbell" },
        machine: { label: "Maquina", icon: "fas fa-cogs" },
        cable: { label: "Polea", icon: "fas fa-wave-square" },
        bodyweight: { label: "Corporal", icon: "fas fa-running" },
        other: { label: "Otro", icon: "fas fa-toolbox" }
    };

    let BODY_PART_MAP = {};

    const translateBodyPart = (bp) => {
        return BODY_PART_MAP[bp] || bp || "N/A";
    };

    const getEquipmentMeta = (equipmentKey) => {
        return EQUIPMENT_MAP[equipmentKey] || { label: equipmentKey || "N/A", icon: "fas fa-dumbbell" };
    };

    const toEmbedUrl = (url) => {
        const trimmed = (url || "").trim();
        if (!trimmed) return "";
        if (trimmed.includes("youtube.com/watch")) {
            const match = trimmed.match(/[?&]v=([^&]+)/);
            if (match && match[1]) return `https://www.youtube.com/embed/${match[1]}`;
        }
        if (trimmed.includes("youtu.be/")) {
            const match = trimmed.match(/youtu\.be\/([^?&]+)/);
            if (match && match[1]) return `https://www.youtube.com/embed/${match[1]}`;
        }
        return trimmed;
    };

    const openVideoModal = (url) => {
        const modalEl = document.getElementById("videoModal");
        const iframe = document.getElementById("videoFrame");
        const embedUrl = toEmbedUrl(url);
        if (!embedUrl) return;
        iframe.src = embedUrl;
        const modal = new bootstrap.Modal(modalEl);
        modalEl.style.zIndex = "4000";
        modalEl.addEventListener("shown.bs.modal", () => {
            const backdrops = document.querySelectorAll(".modal-backdrop");
            const backdrop = backdrops[backdrops.length - 1];
            if (backdrop) backdrop.style.zIndex = "3900";
        }, { once: true });
        modal.show();
        modalEl.addEventListener("hidden.bs.modal", () => {
            iframe.src = "";
            modalEl.style.zIndex = "";
        }, { once: true });
    };

    const resolveSubstitutes = (substitutes, exerciseLookup) => {
        if (!substitutes || substitutes.length === 0) return [];
        return substitutes
            .map(sub => {
                if (typeof sub === "string" || typeof sub === "number") {
                    return exerciseLookup[String(sub)];
                }
                if (sub && typeof sub === "object") {
                    const oid = sub.$oid || sub.oid;
                    if (oid) return exerciseLookup[String(oid)] || null;
                    const subId = sub._id || sub.exercise_id || sub.id;
                    if (subId != null) return exerciseLookup[String(subId)] || sub;
                    return sub;
                }
                return null;
            })
            .filter(Boolean);
    };

    const getExerciseId = (exercise) => {
        if (!exercise) return null;
        const raw = exercise.exercise_id || exercise._id || exercise.id || null;
        if (!raw) return null;
        if (typeof raw === "object") {
            return raw.$oid || raw.oid || null;
        }
        return raw;
    };

    const getExerciseWithLookup = (exercise, exerciseLookup) => {
        if (!exercise) return exercise;
        const exId = getExerciseId(exercise);
        if (!exId) return exercise;
        const fromLookup = exerciseLookup[String(exId)];
        if (!fromLookup) return exercise;
        const merged = { ...fromLookup, ...exercise };
        ["substitutes", "equivalents", "equivalent_exercises"].forEach((field) => {
            const lookupVal = fromLookup[field];
            const exerciseVal = exercise[field];
            if (Array.isArray(lookupVal) && lookupVal.length > 0) {
                if (!Array.isArray(exerciseVal) || exerciseVal.length === 0) {
                    merged[field] = lookupVal;
                }
            }
        });
        return merged;
    };

    const mergeExerciseForSwap = (original, substitute) => {
        if (!substitute) return original;
        const merged = { ...original, ...substitute };
        const substituteId = getExerciseId(substitute);
        if (substituteId) {
            merged.exercise_id = substituteId;
            merged._id = substitute._id || substituteId;
        }
        merged.exercise_name = substitute.exercise_name || substitute.name || original.exercise_name || original.name;
        merged.name = substitute.exercise_name || substitute.name || original.name || original.exercise_name;
        return merged;
    };

    const getRestSeconds = (item) => {
        if (!item) return 60;
        if (item.rest_seconds != null) return item.rest_seconds;
        if (item.rest != null && item.rest !== item.target_time_seconds) return item.rest;
        return 60;
    };

    // --- ENGINE / STATE MACHINE ---

    /**
     * FLATTENS the routine into a linear "Playlist" or Queue of Steps.
     * This handles the complex logic of Circuits/Supersets upfront.
     *
     * Resulting Step Structure:
     * {
     *   id: string,
     *   type: 'work' | 'rest' | 'prep',
     *   exercise: object,
     *   setNumber: number,
     *   totalSets: number,
     *   isTimeBased: boolean,
     *   target: { weight?, reps?, time? },
     *   restAfter: number
     * }
     */
    const buildQueue = (routine) => {
        const queue = [];
        const items = Array.isArray(routine.items) ? routine.items : [];
        const isRestItem = (item) => item && (item.item_type === 'rest' || (!item.exercise_id && item.rest_seconds != null));
        const isExerciseItem = (item) => item && item.item_type === 'exercise';
        const isGroupItem = (item) => item && item.item_type === 'group';
        const groupMeta = new Map();

        items.filter(isGroupItem).forEach(group => {
            groupMeta.set(group._id, {
                name: group.group_name || group.name || 'Grupo',
                note: group.note || ''
            });
        });

        const pushRest = (restItem, key) => {
            queue.push({
                id: `rest_${key}_${queue.length}`,
                type: 'rest',
                duration: parseInt(getRestSeconds(restItem)),
                label: restItem.note || 'Descansar'
            });
        };

        const pushWorkStep = (ex, key, setNumber, totalSets, groupInfo) => {
            const exType = (ex.exercise_type || ex.type);
            const hasTimeTarget = ex.target_time_seconds != null || ex.time_seconds != null || ex.time != null;
            const hasRepsTarget = ex.target_reps != null || ex.reps != null;
            const isTime = exType === 'time' || exType === 'cardio' || (hasTimeTarget && !hasRepsTarget);
            queue.push({
                id: `step_${key}_${setNumber}`,
                routineItemId: ex._id || ex.id, // Stable ID for RoutineDetails lookup (persists through swaps)
                type: 'work',
                exercise: ex,
                groupName: groupInfo ? groupInfo.name : null,
                groupComment: groupInfo ? groupInfo.note : null,
                setNumber,
                totalSets,
                isTimeBased: isTime,
                target: {
                    weight: ex.weight,
                    reps: ex.target_reps || ex.reps,
                    time: ex.target_time_seconds || ex.time_seconds || ex.time || 60
                }
            });
        };

        const hasExplicitRest = (item) => {
            if (!item) return false;
            if (item.rest_seconds != null) return true;
            if (item.rest != null && item.rest !== item.target_time_seconds) return true;
            return false;
        };

        const addStraightSets = (ex, key, groupInfo, addPostRest) => {
            const exSets = parseInt(ex.target_sets || ex.sets || 1);
            for (let s = 1; s <= exSets; s++) {
                pushWorkStep(ex, key, s, exSets, groupInfo);
                if (s < exSets) {
                    queue.push({ type: 'rest', duration: parseInt(getRestSeconds(ex)), label: 'Descansar' });
                }
            }
            if (addPostRest && hasExplicitRest(ex)) {
                queue.push({ type: 'rest', duration: parseInt(getRestSeconds(ex)), label: 'Descansar' });
            }
        };

        const hasEmbeddedGroups = items.some(item => Array.isArray(item.items));
        if (hasEmbeddedGroups) {
            const hasNextWorkAfterIndex = (startIdx) => {
                return items.slice(startIdx + 1).some(item => {
                    if (isRestItem(item)) return false;
                    if (Array.isArray(item.items)) return item.items.some(sub => isExerciseItem(sub));
                    return isExerciseItem(item);
                });
            };

            items.forEach((group, gIdx) => {
                if (isGroupItem(group) && !Array.isArray(group.items)) return;
                if (isRestItem(group)) {
                    pushRest(group, gIdx);
                    return;
                }

                const entries = Array.isArray(group.items) ? group.items : [group];
                const exerciseEntries = entries.filter(isExerciseItem);
                const restEntries = entries.filter(isRestItem);
                if (!exerciseEntries.length && restEntries.length) {
                    restEntries.forEach((restItem, rIdx) => pushRest(restItem, `${gIdx}_${rIdx}`));
                    return;
                }

                const isCircuit = group.item_type === 'group' || (group.items && group.items.length > 1);
                const maxSets = Math.max(...exerciseEntries.map(ex => parseInt(ex.target_sets || ex.sets || 1)));
                const groupInfo = {
                    name: group.name || group.group_name || 'Circuito',
                    note: group.note || ''
                };

                const hasNextWork = hasNextWorkAfterIndex(gIdx);
                for (let s = 1; s <= maxSets; s++) {
                    entries.forEach((entry, exIdx) => {
                        if (isRestItem(entry)) {
                            pushRest(entry, `${gIdx}_${exIdx}_${s}`);
                            return;
                        }
                        if (!isExerciseItem(entry)) return;
                        const exSets = parseInt(entry.target_sets || entry.sets || 1);
                        if (s <= exSets) {
                            pushWorkStep(entry, `${gIdx}_${exIdx}`, s, exSets, groupInfo);

                            const isLastInCircuit = exIdx === entries.length - 1;
                            const isLastSet = s === maxSets;
                            const restTime = parseInt(getRestSeconds(entry));

                            if (isCircuit) {
                                if (isLastInCircuit && !isLastSet) {
                                    queue.push({ type: 'rest', duration: restTime, label: 'Descansar (Fin de Circuito)' });
                                } else if (isLastInCircuit && isLastSet && hasNextWork) {
                                    queue.push({ type: 'rest', duration: restTime, label: 'Descansar (Fin de Circuito)' });
                                }
                            } else if (!isLastSet) {
                                queue.push({ type: 'rest', duration: restTime, label: 'Descansar' });
                            }
                        }
                    });
                }
            });
        } else {
            const groupEntries = new Map();
            const blocks = [];
            const blockIds = new Set();

            const ensureGroupBlock = (groupId) => {
                if (!groupId || blockIds.has(groupId)) return;
                blockIds.add(groupId);
                blocks.push({ type: 'group', id: groupId });
            };

            items.forEach((item, idx) => {
                if (isGroupItem(item)) {
                    ensureGroupBlock(item._id);
                    return;
                }
                if (!isExerciseItem(item) && !isRestItem(item)) return;

                if (item.group_id) {
                    ensureGroupBlock(item.group_id);
                    if (!groupEntries.has(item.group_id)) groupEntries.set(item.group_id, []);
                    groupEntries.get(item.group_id).push(item);
                    return;
                }

                blocks.push({ type: 'entry', entry: item, key: `ungrouped_${idx}` });
            });

            const processedGroups = new Set();
            const hasWorkInBlock = (block) => {
                if (block.type === 'entry') return isExerciseItem(block.entry);
                if (block.type === 'group') {
                    const entries = groupEntries.get(block.id) || [];
                    return entries.some(isExerciseItem);
                }
                return false;
            };
            const hasNextWorkBlock = (blockIdx) => blocks.slice(blockIdx + 1).some(hasWorkInBlock);

            blocks.forEach((block, blockIdx) => {
                if (block.type === 'entry') {
                    const entry = block.entry;
                    if (isRestItem(entry)) {
                        pushRest(entry, block.key);
                    } else if (isExerciseItem(entry)) {
                        addStraightSets(entry, block.key, null, hasNextWorkBlock(blockIdx));
                    }
                    return;
                }

                if (processedGroups.has(block.id)) return;
                processedGroups.add(block.id);
                const entries = groupEntries.get(block.id) || [];
                if (!entries.length) return;

                const exerciseEntries = entries.filter(isExerciseItem);
                const restEntries = entries.filter(isRestItem);
                if (!exerciseEntries.length && restEntries.length) {
                    restEntries.forEach((restItem, rIdx) => pushRest(restItem, `group_${block.id}_${rIdx}`));
                    return;
                }

                const maxSets = Math.max(...exerciseEntries.map(ex => parseInt(ex.target_sets || ex.sets || 1)));
                const groupInfo = groupMeta.has(block.id)
                    ? groupMeta.get(block.id)
                    : { name: 'Grupo', note: '' };
                const hasTrailingRest = entries.length > 0 && isRestItem(entries[entries.length - 1]);

                const hasNextWork = hasNextWorkBlock(blockIdx);
                for (let s = 1; s <= maxSets; s++) {
                    entries.forEach((entry, entryIdx) => {
                        if (isRestItem(entry)) {
                            pushRest(entry, `group_${block.id}_${entryIdx}_${s}`);
                            return;
                        }
                        if (!isExerciseItem(entry)) return;
                        const exSets = parseInt(entry.target_sets || entry.sets || 1);
                        if (s <= exSets) {
                            pushWorkStep(entry, `group_${block.id}_${entryIdx}`, s, exSets, groupInfo);
                        }
                    });

                    if (s < maxSets && !hasTrailingRest) {
                        const lastExercise = exerciseEntries[exerciseEntries.length - 1];
                        const restTime = parseInt(getRestSeconds(lastExercise));
                        queue.push({
                            type: 'rest',
                            duration: restTime,
                            label: groupInfo && groupInfo.name ? `Descansar (${groupInfo.name})` : 'Descansar'
                        });
                    } else if (s === maxSets && !hasTrailingRest && hasNextWork) {
                        const lastExercise = exerciseEntries[exerciseEntries.length - 1];
                        const restTime = parseInt(getRestSeconds(lastExercise));
                        queue.push({
                            type: 'rest',
                            duration: restTime,
                            label: groupInfo && groupInfo.name ? `Descansar (${groupInfo.name})` : 'Descansar'
                        });
                    }
                }
            });
        }


        return queue;
    };

    const WorkoutContext = createContext();

    const WorkoutProvider = ({ children, routine }) => {
        const [queue, setQueue] = useState([]);
        const [cursor, setCursor] = useState(0); // Index in Queue
        const [status, setStatus] = useState('LOADING'); // LOADING | IDLE | WORK | REST | FINISHED
        const [sessionLog, setSessionLog] = useState([]);
        const [historyMaxByExercise, setHistoryMaxByExercise] = useState({});
        const [exerciseLookup, setExerciseLookup] = useState({});
        const [isPaused, setIsPaused] = useState(false);
        const [message, setMessage] = useState(null);
        const [confirmModal, setConfirmModal] = useState({ isOpen: false, title: "", message: "", onConfirm: null, type: "danger" }); // type: danger | warning | info
        const [substituteModal, setSubstituteModal] = useState({ isOpen: false, stepIndex: null });
        const [showCompletionIcon, setShowCompletionIcon] = useState(false);
        const [showCountdown, setShowCountdown] = useState(false);
        const [countdownValue, setCountdownValue] = useState(3);


        // Timers
        const [globalTime, setGlobalTime] = useState(0);
        const [stepTimer, setStepTimer] = useState(0); // For Rest or Time-based work
        const [isTimerRunning, setIsTimerRunning] = useState(false);

        // Refs for Interval
        const stepIntervalRef = useRef(null);
        const resumeTimerRef = useRef(false);
        const onConfirmRef = useRef(null);
        const queueRef = useRef([]);
        const sessionLogRef = useRef([]); // Fix for stale closure
        const startTimeRef = useRef(Date.now()); // Track start time of current step
        const visibilitySnapshotRef = useRef(null);
        const completeStepTimerRef = useRef(null);
        const statusRef = useRef(status);
        const isPausedRef = useRef(isPaused);
        const isTimerRunningRef = useRef(isTimerRunning);
        const stepTimerRef = useRef(stepTimer);
        const globalTimeRef = useRef(globalTime);
        const currentStepRef = useRef(null);


        // INITIALIZE
        useEffect(() => {
            if (routine) {
                const q = buildQueue(routine);
                setQueue(q);
                setStatus('IDLE');

                // Hydrate from restored state
                if (RESTORED_STATE && RESTORED_STATE.routine_id === routine.id) {
                    console.log("RESTORING STATE:", RESTORED_STATE);
                    if (RESTORED_STATE.cursor > 0 && RESTORED_STATE.cursor < q.length) {
                        setCursor(RESTORED_STATE.cursor);

                        // AUTO-RESUME: Set status to WORK and ensure timer logic runs
                        // We check the upcoming step type to decide WORK vs REST
                        const resumeStep = q[RESTORED_STATE.cursor];
                        if (resumeStep) {
                            if (resumeStep.type === 'rest') {
                                setStatus('REST');
                                setStepTimer(resumeStep.duration); // Reset timer to full duration? Or should we save timer state? 
                                // User asked "resume where leftover", assuming step is enough.
                                setIsTimerRunning(true);
                            } else {
                                setStatus('WORK');
                                setStepTimer(resumeStep.isTimeBased ? resumeStep.target.time : 0);
                                setIsTimerRunning(resumeStep.isTimeBased);
                            }
                        }
                    }
                    if (RESTORED_STATE.session_log) {
                        setSessionLog(RESTORED_STATE.session_log);
                        sessionLogRef.current = RESTORED_STATE.session_log;
                    }
                }

                console.log("Queue Built:", q);
                queueRef.current = q; // Update ref
            }
        }, [routine]);

        // Reset start time when step changes
        useEffect(() => {
            startTimeRef.current = Date.now();
        }, [cursor]); // Reset on cursor change

        useEffect(() => {
            let isMounted = true;
            const loadExercises = async () => {
                try {
                    const res = await fetch("/workout/api/exercises");
                    if (!res.ok) return;
                    const data = await res.json();
                    if (!isMounted || !Array.isArray(data)) return;
                    const lookup = data.reduce((acc, ex) => {
                        if (ex && ex._id) acc[ex._id] = ex;
                        if (ex && ex.exercise_id) acc[String(ex.exercise_id)] = ex;
                        return acc;
                    }, {});
                    setExerciseLookup(lookup);
                } catch (e) { console.error("Error loading exercises", e); }
            };

            const loadBodyParts = async () => {
                try {
                    const res = await fetch("/workout/api/body-parts");
                    const parts = await res.json();
                    parts.forEach(p => {
                        BODY_PART_MAP[p.key] = p.label_es || p.label_en || p.key;
                    });
                    setExerciseLookup(prev => ({ ...prev }));
                } catch (e) { console.error("Error loading body parts", e); }
            };

            const init = async () => {
                if (window.showLoader) window.showLoader("Cargando motor...");
                try {
                    await Promise.all([loadExercises(), loadBodyParts()]);
                } finally {
                    if (window.hideLoader) window.hideLoader();
                }
            };

            init();

            return () => { isMounted = false; };
        }, []);

        useEffect(() => {
            let isMounted = true;
            const routineId = routine?.id || routine?._id;
            if (!CURRENT_USER_ID || !routineId) return;

            const loadHistoryMax = async () => {
                if (window.showLoader) window.showLoader("Sincronizando historial...");
                try {
                    const res = await fetch(`/workout/api/sessions?user_id=${encodeURIComponent(CURRENT_USER_ID)}&limit=50`);
                    if (!res.ok) return;
                    const sessions = await res.json();
                    if (!isMounted || !Array.isArray(sessions)) return;

                    const maxByExercise = {};
                    sessions.forEach(session => {
                        if (!session || session.routine_id !== routineId) return;
                        const sets = Array.isArray(session.sets) ? session.sets : [];
                        sets.forEach(set => {
                            const exId = set.exerciseId || set.exercise_id;
                            if (!exId) return;
                            const weightVal = parseFloat(set.weight);
                            if (!Number.isFinite(weightVal) || weightVal <= 0) return;
                            if (maxByExercise[exId] == null || weightVal > maxByExercise[exId]) {
                                maxByExercise[exId] = weightVal;
                            }
                        });
                    });

                    setHistoryMaxByExercise(maxByExercise);
                } catch (e) {
                    console.error("Error loading session history", e);
                } finally {
                    if (window.hideLoader) window.hideLoader();
                }
            };

            loadHistoryMax();
            return () => { isMounted = false; };
        }, [routine]);

        // Wake Lock Implementation - Robust & Status Aware
        const isActive = status === 'WORK' || status === 'REST';

        useEffect(() => {
            let wakeLock = null;

            const requestLock = async () => {
                if (!isActive) return;
                // Only request if visible
                if (document.visibilityState !== 'visible') return;

                try {
                    if ('wakeLock' in navigator) {
                        try {
                            wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Pantalla activa: Wake Lock adquirido');
                            wakeLock.addEventListener('release', () => {
                                console.log('Pantalla normal: Wake Lock liberado');
                            });
                        } catch (e) {
                            console.log("Wake Lock request failed", e);
                        }
                    } else {
                        console.warn('Este navegador no soporta Wake Lock API');
                    }
                } catch (err) {
                    console.error(`Wake Lock Error: ${err.name}, ${err.message}`);
                }
            };

            const releaseLock = async () => {
                if (wakeLock !== null) {
                    try {
                        await wakeLock.release();
                        wakeLock = null;
                    } catch (e) {
                        console.log("Wake Lock release error (ignore)", e);
                    }
                }
            };

            const handleVisibilityChange = () => {
                // If we come back to visible and we ARE active, re-request
                if (document.visibilityState === 'visible' && isActive) {
                    requestLock();
                }
            };

            if (isActive) {
                requestLock();
                document.addEventListener('visibilitychange', handleVisibilityChange);
            } else {
                releaseLock();
            }

            return () => {
                releaseLock();
                document.removeEventListener('visibilitychange', handleVisibilityChange);
            };
        }, [isActive]);


        // Global Timer (only when actively working or resting)
        useEffect(() => {
            if (status !== 'WORK' && status !== 'REST' || isPaused) return;
            const int = setInterval(() => setGlobalTime(t => t + 1), 1000);
            return () => clearInterval(int);
        }, [status, isPaused]);

        // Step Timer Logic (Countdown)
        useEffect(() => {
            if (isPaused) {
                clearInterval(stepIntervalRef.current);
                return;
            }
            if (isTimerRunning && stepTimer > 0) {
                stepIntervalRef.current = setInterval(() => {
                    setStepTimer(prev => {
                        if (prev <= 1) {
                            // TIMER DONE
                            playAlarm();
                            setIsTimerRunning(false);
                            completeStepTimer(); // Auto-advance logic
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            } else {
                clearInterval(stepIntervalRef.current);
            }
            return () => clearInterval(stepIntervalRef.current);
        }, [isTimerRunning, stepTimer, isPaused]);

        const playAlarm = () => {
            try {
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                getAudio().play().catch(e => console.log("Audio permission needed"));
            } catch (e) { }
        }

        const currentStep = useMemo(() => queue[cursor], [queue, cursor]);
        const nextStep = useMemo(() => queue[cursor + 1], [queue, cursor]);

        useEffect(() => { statusRef.current = status; }, [status]);
        useEffect(() => { isPausedRef.current = isPaused; }, [isPaused]);
        useEffect(() => { isTimerRunningRef.current = isTimerRunning; }, [isTimerRunning]);
        useEffect(() => { stepTimerRef.current = stepTimer; }, [stepTimer]);
        useEffect(() => { globalTimeRef.current = globalTime; }, [globalTime]);
        useEffect(() => { currentStepRef.current = currentStep; }, [currentStep]);

        // Auto-advance logic when timer hits 0
        const completeStepTimer = () => {
            if (currentStep.type === 'rest') {
                next(); // Auto-skip rest when done
            } else {
                // For Work (Time based), we ensure it is logged
                const alreadyLogged = sessionLog.some(l => l.stepId === currentStep.id);
                if (!alreadyLogged) {
                    logSet({
                        time_seconds: currentStep.target.time,
                        weight: 0,
                        reps: 0
                    });
                }
                next();
            }
        };

        useEffect(() => {
            completeStepTimerRef.current = completeStepTimer;
        }, [completeStepTimer]);

        useEffect(() => {
            const handleVisibilityChange = () => {
                if (document.visibilityState === 'hidden') {
                    visibilitySnapshotRef.current = {
                        hiddenAt: Date.now(),
                        status: statusRef.current,
                        isPaused: isPausedRef.current,
                        isTimerRunning: isTimerRunningRef.current,
                        stepTimer: stepTimerRef.current,
                        globalTime: globalTimeRef.current
                    };
                    return;
                }
                if (document.visibilityState !== 'visible') return;
                const snap = visibilitySnapshotRef.current;
                visibilitySnapshotRef.current = null;
                if (!snap || snap.isPaused) return;
                if (snap.status !== 'WORK' && snap.status !== 'REST') return;

                const deltaSec = Math.floor((Date.now() - snap.hiddenAt) / 1000);
                if (deltaSec <= 0) return;

                setGlobalTime(current => Math.max(current, snap.globalTime + deltaSec));

                if (snap.isTimerRunning && snap.stepTimer > 0) {
                    const nextTimer = Math.max(0, snap.stepTimer - deltaSec);
                    if (nextTimer <= 0) {
                        setStepTimer(0);
                        setIsTimerRunning(false);
                        if (completeStepTimerRef.current) {
                            completeStepTimerRef.current();
                        }
                    } else {
                        setStepTimer(prev => Math.min(prev, nextTimer));
                    }
                }
            };

            document.addEventListener('visibilitychange', handleVisibilityChange);
            return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
        }, []);

        const logSet = (data) => {
            const exerciseId = currentStep.exercise?.exercise_id || currentStep.exercise?._id || currentStep.exercise?.id;
            const exerciseName = currentStep.exercise?.exercise_name || currentStep.exercise?.name;
            const exerciseType = currentStep.exercise?.exercise_type || currentStep.exercise?.type;
            const resolvedTime = data.time_seconds != null
                ? data.time_seconds
                : (currentStep.isTimeBased ? currentStep.target?.time : null);
            const baseLog = (sessionLogRef && sessionLogRef.current) ? sessionLogRef.current : sessionLog;
            const newLog = [...baseLog, {
                stepId: currentStep.id,
                exerciseId,
                exercise_id: exerciseId,
                name: exerciseName,
                exercise_type: exerciseType,
                weight: 0,
                reps: 0,
                ...data,
                duration_seconds: (Date.now() - startTimeRef.current) / 1000,
                ...(resolvedTime != null ? { time_seconds: resolvedTime } : {}),
                timestamp: new Date()
            }];

            setSessionLog(newLog);
            sessionLogRef.current = newLog; // Immediate update

            // Sync Progress
            syncProgress(cursor, newLog);
        };

        const syncProgress = async (idx, log) => {
            // Debounce or just fire? Fire for now, robustness.
            try {
                await fetch("/workout/api/session/progress", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        routine_id: routine.id,
                        cursor: idx,
                        session_log: log || sessionLogRef.current // Use arg or ref
                    })
                });
            } catch (e) { console.error("Sync error", e); }
        };

        const next = () => {
            console.log("DEBUG: Next called. Cursor:", cursor, "QueueLen:", queue.length);

            // AUTO-LOG CHECK: If moving away from a WORK step that hasn't been logged, log it now.
            if (currentStep && currentStep.type === 'work') {
                const currentLog = (sessionLogRef && sessionLogRef.current) ? sessionLogRef.current : sessionLog;
                const alreadyLogged = currentLog.some(l => l.stepId === currentStep.id);
                if (!alreadyLogged) {
                    console.log("DEBUG: Auto-logging skipped/done work step:", currentStep.id);
                    // Use target time or elapsed time? 
                    // If isTimeBased, probably use target if manually done "as complete", or elapsed. 
                    // Let's use target time if available, else 0.
                    const fallbackTime = currentStep.isTimeBased ? currentStep.target.time : 0;
                    logSet({
                        time_seconds: fallbackTime,
                        weight: 0,
                        reps: 0
                    });
                    // Note: logSet is async state update. next() continues below. 
                    // We need to pass the *updated* log to syncProgress, but we can't get it immediately.
                    // syncProgress inside next() uses sessionLog closure. 
                    // We should rely on logSet calling syncProgress internally.
                    // BUT next() calls syncProgress too. 
                }
            }

            if (cursor >= queue.length - 1) {
                finishWorkout();
                return;
            }
            const nextIdx = cursor + 1;
            setCursor(nextIdx);
            setIsPaused(false);

            // Sync Progress (using current log)
            syncProgress(nextIdx, (sessionLogRef && sessionLogRef.current) ? sessionLogRef.current : sessionLog);

            // Setup next step state
            const upcoming = queue[nextIdx];
            if (upcoming.type === 'rest') {
                setStatus('REST');
                setStepTimer(upcoming.duration);
                setIsTimerRunning(true);
            } else {
                // Work Step
                setStatus('WORK');
                setStepTimer(upcoming.isTimeBased ? upcoming.target.time : 0);
                setIsTimerRunning(upcoming.isTimeBased); // Start immediately if timed? User said "Sonar alarma y pasar...". Usually explicit start is safer but for flow dynamic is ok.
            }
        };

        const skipToNextWork = () => {
            console.log("DEBUG: Skip to next work. Cursor:", cursor, "QueueLen:", queue.length);
            if (cursor >= queue.length - 1) {
                finishWorkout();
                return;
            }
            let nextIdx = cursor + 1;
            while (nextIdx < queue.length && queue[nextIdx].type === 'rest') {
                nextIdx += 1;
            }
            if (nextIdx >= queue.length) {
                finishWorkout();
                return;
            }
            const upcoming = queue[nextIdx];
            setCursor(nextIdx);
            setIsPaused(false);
            setStatus('WORK');
            setStepTimer(upcoming.isTimeBased ? upcoming.target.time : 0);
            setIsTimerRunning(upcoming.isTimeBased);
        };

        const prev = () => {
            if (cursor <= 0) return;
            let idx = cursor - 1;
            while (idx >= 0 && queue[idx].type === 'rest') {
                idx -= 1;
            }
            if (idx < 0) return;
            setCursor(idx);
            setIsTimerRunning(false);
            setIsPaused(false);
            const prevStep = queue[idx];
            setStatus('WORK');
            setStepTimer(prevStep.isTimeBased ? prevStep.target.time : 0);
        };

        const skipRest = () => {
            setIsTimerRunning(false);
            setIsPaused(false);
            showMessage("Descanso omitido", "info");
            next();
        };

        const addRestTime = (seconds) => {
            setStepTimer(t => {
                if (seconds < 0 && t < 10) return t;
                const nextValue = t + seconds;
                return Math.max(0, nextValue);
            });
        };

        const finishWorkout = async () => {
            if (status === 'FINISHED') return; // Prevent double trigger

            // 1. Show Icon
            setShowCompletionIcon(true);

            // 2. Wait 2 seconds then show modal
            setTimeout(() => {
                setShowCompletionIcon(false);
                showConfirm("Finalizar Rutina", "Deseas guardar el entrenamiento completado?", async () => {
                    setStatus('FINISHED');
                    if (window.showLoader) window.showLoader("Guardando sesin...");
                    // Save logic
                    try {
                        const payload = {
                            routine_id: routine.id,
                            start_time: new Date(Date.now() - globalTime * 1000).toISOString(),
                            end_time: new Date().toISOString(),
                            sets: sessionLogRef.current // Use REF to ensure latest data
                        };
                        const res = await fetch("/workout/api/session/save", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        if (res.ok) window.location.href = getReturnUrl();
                    } catch (e) {
                        showAlertModal("Error", "Error saving: " + e.message, "danger");
                    } finally {
                        if (window.hideLoader) window.hideLoader();
                    }
                }, "success");
            }, 2000);
        };

        const cancelWorkout = () => {
            const doCancel = async () => {
                try {
                    await fetch("/workout/api/session/cancel", { method: "POST" });
                } catch (e) { console.error("Error cancelling:", e); }
                window.location.href = getReturnUrl();
            };

            if (status === 'IDLE') {
                doCancel();
                return;
            }
            showConfirm("Cancelar Rutina", "Ests seguro de que quieres salir? Se perder el progreso actual.", () => {
                showMessage("Rutina cancelada", "error");
                doCancel();
            }, "danger");
        };

        const showMessage = (text, tone = "info") => {
            setMessage({ text, tone });
            setTimeout(() => setMessage(null), 3000);
        };

        const openSubstituteModal = (stepIndex = cursor) => {
            const step = queue[stepIndex];
            if (!step || step.type !== 'work') return;
            setSubstituteModal({ isOpen: true, stepIndex });
        };

        const closeSubstituteModal = () => {
            setSubstituteModal({ isOpen: false, stepIndex: null });
        };

        const applySubstitute = (subExercise, scope = "current", stepIndex = null) => {
            if (!subExercise) return;
            const targetIndex = stepIndex != null ? stepIndex : cursor;
            setQueue(prevQueue => {
                const targetStep = prevQueue[targetIndex];
                if (!targetStep || targetStep.type !== 'work') return prevQueue;
                const targetId = getExerciseId(targetStep.exercise);
                const replaceStep = (step) => ({
                    ...step,
                    exercise: mergeExerciseForSwap(step.exercise, subExercise)
                });

                return prevQueue.map((step, idx) => {
                    if (step.type !== 'work') return step;
                    if (scope === "current") {
                        return idx === targetIndex ? replaceStep(step) : step;
                    }
                    if (idx < targetIndex) return step;
                    const stepId = getExerciseId(step.exercise);
                    if (!targetId) {
                        return idx === targetIndex ? replaceStep(step) : step;
                    }
                    if (stepId && targetId && stepId === targetId) {
                        return replaceStep(step);
                    }
                    return step;
                });
            });
            showMessage("Sustituto aplicado", "success");
            closeSubstituteModal();
        };

        const togglePause = () => {
            if (status !== 'WORK' && status !== 'REST') return;
            if (!isPaused) {
                resumeTimerRef.current = isTimerRunning;
                setIsTimerRunning(false);
                setIsPaused(true);
                return;
            }
            setIsPaused(false);
            if (resumeTimerRef.current || status === 'REST') {
                setIsTimerRunning(true);
            }
        };

        const startWorkout = () => {
            if (!queue || queue.length === 0) return;

            console.log("Starting countdown...");
            setCountdownValue(3);
            setShowCountdown(true);

            // Fetch session start immediately to lock it
            fetch("/workout/api/session/start", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ routine_id: routine.id })
            }).catch(e => console.error("Start session error", e));

            const interval = setInterval(() => {
                setCountdownValue(prev => {
                    if (prev <= 1) {
                        clearInterval(interval);
                        setShowCountdown(false);

                        console.log("Countdown finished, starting workout...");
                        // Actual start logic
                        const step = queueRef.current[cursor]; // Use ref to avoid stale queue
                        setIsPaused(false);
                        if (step && step.type === 'rest') {
                            setStatus('REST');
                            setStepTimer(step.duration);
                            setIsTimerRunning(true);
                        } else if (step) {
                            setStatus('WORK');
                            setStepTimer(step.isTimeBased ? step.target.time : 0);
                            setIsTimerRunning(step.isTimeBased);
                        }
                        return 0;
                    }
                    return prev - 1;
                });
            }, 1000);
        };

        const showConfirm = (title, message, onConfirm, type = "danger") => {
            console.log("DEBUG: showConfirm called", { title });
            onConfirmRef.current = onConfirm;
            setConfirmModal({ isOpen: true, title, message, type });
        };

        const closeConfirm = () => {
            setConfirmModal(prev => ({ ...prev, isOpen: false }));
            // Optional: onConfirmRef.current = null; // Keep it or clear it.
        };

        const handleConfirmAction = () => {
            console.log("DEBUG: handleConfirmAction called. Has Ref?", !!onConfirmRef.current);
            if (onConfirmRef.current) {
                console.log("DEBUG: Executing onConfirm callback via REF");
                onConfirmRef.current();
            }
            closeConfirm();
        };


        const value = {
            routine,
            queue,
            cursor,
            currentStep,
            nextStep,
            status,
            globalTime,
            stepTimer,
            isTimerRunning,
            setIsTimerRunning,
            next,
            prev,
            skipToNextWork,
            skipRest,
            addRestTime,
            logSet,
            logSet,
            sessionLog,
            sessionLogRef,
            historyMaxByExercise,
            finishWorkout,
            startWorkout,
            cancelWorkout,
            exerciseLookup,
            isPaused,
            togglePause,
            message,
            showMessage,
            confirmModal,
            showConfirm,
            closeConfirm,
            handleConfirmAction,
            substituteModal,
            openSubstituteModal,
            closeSubstituteModal,
            applySubstitute,
            showCompletionIcon,
            showCountdown,
            countdownValue
        };


        return <WorkoutContext.Provider value={value}>{children}</WorkoutContext.Provider>;
    };

    const useWorkout = () => useContext(WorkoutContext);

    const ConfirmModal = () => {
        const { confirmModal, closeConfirm, handleConfirmAction } = useWorkout();
        if (!confirmModal.isOpen) return null;

        const { title, message, type } = confirmModal;
        const colorClass = type === 'danger' ? 'text-danger' : type === 'warning' ? 'text-cyber-orange' : 'text-cyber-green';
        const btnClass = type === 'danger' ? 'btn-outline-danger' : type === 'warning' ? 'btn-outline-warning' : 'btn-outline-success';

        return (
            <div className="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-black-trans animate-slide-up" style={{ zIndex: 3000 }}>
                <div className="card bg-black border border-secondary shadow-lg p-3" style={{ maxWidth: '90%', width: '350px', borderRadius: '15px' }}>
                    <div className="card-body text-center">
                        <h4 className={`fw-bold mb-3 ${colorClass}`}>{title}</h4>
                        <p className="text-white mb-4 fs-5">{message}</p>
                        <div className="d-flex gap-3 justify-content-center">
                            <button className="btn btn-secondary flex-grow-1" onClick={closeConfirm}>Cancelar</button>
                            <button className={`btn ${btnClass} flex-grow-1 fw-bold`} onClick={handleConfirmAction}>Confirmar</button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };



    // --- UI COMPONENTS ---



    const MessageBar = () => {
        const { message } = useWorkout();
        if (!message) return null;
        const toneClass = message.tone === "error"
            ? "border-danger text-danger"
            : message.tone === "success"
                ? "border-success text-cyber-green"
                : "border-info text-info";
        return (
            <div className={`mx-3 mb-3 p-2 border rounded bg-black-trans small ${toneClass}`}>
                {message.text}
            </div>
        );
    };

    const RoutineDetails = ({ routine }) => {
        const { exerciseLookup, applySubstitute, showConfirm, queue } = useWorkout();
        // Collapsed by default: We track EXPANDED groups.
        const [expandedGroups, setExpandedGroups] = useState(new Set());
        const [blocks, setBlocks] = useState([]);

        // Toggles group expansion
        const toggleGroup = (groupId) => {
            const next = new Set(expandedGroups);
            if (next.has(groupId)) {
                next.delete(groupId);
            } else {
                next.add(groupId);
            }
            setExpandedGroups(next);
        };

        // Build View Model: Clustered Blocks (Matches buildQueue execution logic)
        useEffect(() => {
            if (!routine || !routine.items) {
                setBlocks([]);
                return;
            }

            const items = Array.isArray(routine.items) ? routine.items : [];
            const isRestItem = (item) => item && (item.item_type === 'rest' || (!item.exercise_id && item.rest_seconds != null));
            const isExerciseItem = (item) => item && item.item_type === 'exercise';
            const isGroupHeader = (item) => item && item.item_type === 'group';
            const buildEntry = (item) => (isRestItem(item) ? { type: 'rest', data: item } : { type: 'exercise', data: item });

            // 1. Map Group Metadata
            const groupMetaMap = new Map();
            items.forEach(item => {
                if (isGroupHeader(item)) {
                    groupMetaMap.set(item._id || item.id, {
                        name: item.group_name || item.name || "Circuito",
                        note: item.note || item.description || ""
                    });
                }
            });

            // 2. Cluster
            const newBlocks = [];
            const blockIds = new Set();
            const groupEntries = new Map();

            const ensureGroupBlock = (groupId) => {
                if (!groupId || blockIds.has(groupId)) return;
                blockIds.add(groupId);
                newBlocks.push({ type: 'group', id: groupId });
            };

            items.forEach((item, idx) => {
                // Inline groups handling
                if (item.item_type === 'group' || Array.isArray(item.items)) {
                    if (Array.isArray(item.items) && item.items.length > 0) {
                        const entries = item.items
                            .filter(sub => isExerciseItem(sub) || isRestItem(sub))
                            .map(buildEntry);
                        if (entries.length > 0) {
                            newBlocks.push({
                                type: 'inline_group',
                                item: item,
                                entries: entries
                            });
                        }
                        return;
                    }
                    ensureGroupBlock(item._id || item.id);
                    return;
                }

                if (isExerciseItem(item) || isRestItem(item)) {
                    const gid = item.group_id;
                    if (gid) {
                        ensureGroupBlock(gid);
                        if (!groupEntries.has(gid)) groupEntries.set(gid, []);
                        groupEntries.get(gid).push(buildEntry(item));
                    } else {
                        newBlocks.push({ type: 'ungrouped', entry: buildEntry(item) });
                    }
                }
            });

            // Post-process to attach entries to blocks for easier rendering
            const validBlocks = newBlocks.map(block => {
                if (block.type === 'group') {
                    const entries = groupEntries.get(block.id) || [];
                    const meta = groupMetaMap.get(block.id) || { name: "Circuito", note: "" };
                    if (entries.length === 0) return null; // Skip empty groups
                    return { ...block, entries, name: meta.name, note: meta.note };
                }
                return block;
            }).filter(Boolean);

            // Consolidate consecutive ungrouped blocks for UI
            const consolidatedBlocks = [];
            let currentUngroupedRequest = null;

            validBlocks.forEach(block => {
                if (block.type === 'ungrouped') {
                    if (!currentUngroupedRequest) {
                        currentUngroupedRequest = { type: 'ungrouped_chunk', entries: [] };
                        consolidatedBlocks.push(currentUngroupedRequest);
                    }
                    currentUngroupedRequest.entries.push(block.entry);
                } else {
                    currentUngroupedRequest = null;
                    consolidatedBlocks.push(block);
                }
            });

            setBlocks(consolidatedBlocks);

        }, [routine]);

        // Helper to count Exercises (total)
        const totalExercises = blocks.reduce((acc, block) => {
            if (block.entries) {
                return acc + block.entries.filter(e => e.type === 'exercise').length;
            }
            return acc;
        }, 0);

        // Find the first queue index for a given exercise ID (for swapping)
        // Find the first queue index for a given exercise ID (for swapping)
        const findStepIndex = (routineItemId) => {
            if (!queue || !routineItemId) return -1;
            return queue.findIndex(step => {
                if (step.type !== 'work') return false;
                // Use the stable routineItemId added in buildQueue
                return String(step.routineItemId) === String(routineItemId);
            });
        };

        // Helper to render an individual entry
        const renderEntry = (entry, key) => {
            if (entry.type === 'rest') {
                const restSeconds = getRestSeconds(entry.data);
                const restLabel = entry.data.note || "Descanso";
                return (
                    <div key={key} className="d-flex justify-content-between align-items-center border border-secondary rounded px-2 py-2 bg-black-trans">
                        <div>
                            <div className="text-white fw-bold">{restLabel}</div>
                            <div className="text-secondary small">Pausa</div>
                        </div>
                        <div class="text-end text-secondary small">
                            <div>{restSeconds}s</div>
                        </div>
                    </div>
                );
            }

            // Original Item Data (Static)
            const item = entry.data || {};
            const routineItemId = item._id || item.id;

            // Resolve Dynamic State from Queue
            // We find the first step corresponding to this routine item to get the *current* exercise (handling swaps)
            const stepIdx = findStepIndex(routineItemId);
            const step = stepIdx !== -1 ? queue[stepIdx] : null;

            // Use Step Exercise if available (swapped), else fallback to original item
            const ex = step ? step.exercise : item;
            const mergedEx = getExerciseWithLookup(ex, exerciseLookup);

            const isTime = (mergedEx.exercise_type || mergedEx.type) === 'time' || (mergedEx.exercise_type || mergedEx.type) === 'cardio';
            const name = mergedEx.exercise_name || mergedEx.name || "Ejercicio";
            const bodyPartLabel = translateBodyPart(mergedEx.body_part);
            const equipmentMeta = getEquipmentMeta(mergedEx.equipment);
            const hasVideo = mergedEx.video_url && mergedEx.video_url.trim() !== "";
            // FIX: Use comprehensive lookup like SubstitutesModal
            const substitutes = resolveSubstitutes(
                mergedEx.substitutes || mergedEx.equivalents || mergedEx.equivalent_exercises || [],
                exerciseLookup
            );
            const subsId = `subs_${key}`;
            const sets = mergedEx.target_sets || mergedEx.sets || 1;
            const reps = mergedEx.target_reps || mergedEx.reps;
            const time = mergedEx.target_time_seconds || mergedEx.time_seconds;
            const restSeconds = getRestSeconds(mergedEx);

            return (
                <div key={key} className="d-flex justify-content-between align-items-start gap-3">
                    <div>
                        <div className="d-flex align-items-center gap-2">
                            <div className="text-white fw-bold">{name}</div>
                            {hasVideo && (
                                <button
                                    type="button"
                                    className="btn btn-sm btn-outline-danger"
                                    title="Ver video"
                                    onClick={() => openVideoModal(mergedEx.video_url)}
                                >
                                    <i className="fab fa-youtube"></i>
                                </button>
                            )}
                        </div>
                        <div className="text-secondary small d-flex flex-wrap gap-2 mt-1">
                            <span className="badge bg-secondary">{bodyPartLabel}</span>
                            <span className="badge bg-dark border border-secondary text-info">
                                <i className={`${equipmentMeta.icon} me-1`}></i>{equipmentMeta.label}
                            </span>
                        </div>
                        {(mergedEx.comment || mergedEx.note) && (
                            <div className="mt-2 text-warning small fst-italic">
                                <i className="fas fa-sticky-note me-1"></i> {mergedEx.comment || mergedEx.note}
                            </div>
                        )}
                        {substitutes.length > 0 && (
                            <div className="mt-2">
                                <button
                                    className="btn btn-sm btn-outline-info"
                                    type="button"
                                    data-bs-toggle="collapse"
                                    data-bs-target={`#${subsId}`}
                                    aria-expanded="false"
                                    aria-controls={subsId}
                                >
                                    Sustitutos ({substitutes.length})
                                </button>
                                <div className="collapse mt-2" id={subsId}>
                                    <div className="d-flex flex-column gap-2">
                                        {substitutes.map((sub, sIdx) => {
                                            const subEquipment = getEquipmentMeta(sub.equipment);
                                            const subHasVideo = sub.video_url && sub.video_url.trim() !== "";
                                            return (
                                                <div key={`${key}_sub_${sIdx}`} className="d-flex align-items-center justify-content-between border border-secondary rounded px-2 py-2">
                                                    <div>
                                                        <div className="fw-bold text-white">{sub.name || "Ejercicio"}</div>
                                                        <div className="small text-secondary">
                                                            <i className={`${subEquipment.icon} me-1`}></i>{subEquipment.label}
                                                        </div>
                                                    </div>
                                                    <div className="d-flex align-items-center gap-2">
                                                        {subHasVideo && (
                                                            <button
                                                                type="button"
                                                                className="btn btn-sm btn-outline-danger"
                                                                title="Ver video"
                                                                onClick={() => openVideoModal(sub.video_url)}
                                                            >
                                                                <i className="fab fa-youtube"></i>
                                                            </button>
                                                        )}
                                                        {stepIdx !== -1 && (
                                                            <button
                                                                type="button"
                                                                className="btn btn-sm btn-outline-success"
                                                                title="Usar este ejercicio"
                                                                onClick={() => {
                                                                    const subName = sub.exercise_name || sub.name || "Ejercicio";
                                                                    const subEquip = getEquipmentMeta(sub.equipment).label;
                                                                    const origEquip = getEquipmentMeta(mergedEx.equipment).label;
                                                                    showConfirm(
                                                                        "Confirmar sustituto",
                                                                        `Aplicar "${subName}" (${subEquip}) en lugar de "${name}" (${origEquip}) a todas las series?`,
                                                                        () => applySubstitute(sub, "remaining", stepIdx),
                                                                        "warning"
                                                                    );
                                                                }}
                                                            >
                                                                Usar
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="text-end text-secondary small">
                        <div>{sets} sets {isTime ? `x ${time || 60}s` : `x ${reps || '-'}`}</div>
                        <div>Descanso {restSeconds}s</div>
                    </div>
                </div>
            );
        };

        if (!routine) return <div className="text-white text-center">No routine data</div>;

        return (
            <div className="card mx-3" style={{ background: 'rgba(30,30,30,0.95)', border: '1px solid var(--border-color)', borderRadius: '20px', minHeight: '300px', opacity: 1 }}>
                <div className="card-body">
                    <div className="text-center mb-4">
                        <h2 className="display-6 fw-bold text-white mb-2">{routine.name || "Rutina"}</h2>
                        <p className="text-secondary m-0">{totalExercises} ejercicios -  Revisa los detalles antes de iniciar</p>
                    </div>

                    <div className="d-flex flex-column gap-3 overflow-auto custom-scroll" style={{ maxHeight: '240px' }}>
                        {blocks.map((block, idx) => {
                            // Render Group Block
                            if (block.type === 'group' || block.type === 'inline_group') {
                                const blockId = block.id || (block.item && (block.item._id || block.item.id)) || `grp_${idx}`;
                                const blockName = block.name || (block.item && (block.item.group_name || block.item.name)) || "Circuito";
                                const blockNote = block.note || (block.item && (block.item.note || block.item.description)) || "";
                                const isExpanded = expandedGroups.has(blockId);

                                return (
                                    <div key={`routine_group_${idx}`} className="p-3 border border-secondary rounded-3 bg-black-trans">
                                        <div
                                            className="d-flex justify-content-between align-items-center cursor-pointer"
                                            onClick={() => toggleGroup(blockId)}
                                        >
                                            <div>
                                                <div className="text-cyber-orange text-uppercase small fw-bold">
                                                    {blockName} ({block.entries.length} items)
                                                </div>
                                                {blockNote && <div className="text-white small mt-1 fst-italic">"{blockNote}"</div>}
                                            </div>
                                            <i className={`fas fa-chevron-down text-secondary transition-icon ${isExpanded ? 'rotate-180' : ''}`}></i>
                                        </div>
                                        {isExpanded && (
                                            <div className="d-flex flex-column gap-2 mt-3 animate-fade-in">
                                                {block.entries.map((entry, entryIdx) => renderEntry(entry, `b${idx}_${entryIdx}`))}
                                            </div>
                                        )}
                                    </div>
                                );
                            } else if (block.type === 'ungrouped_chunk') {
                                // Render Ungrouped Block Header + Entries
                                return (
                                    <div key={`routine_block_${idx}`} className="p-3 border border-secondary rounded-3 bg-black-trans">
                                        <div className="text-cyber-blue fw-bold mb-2">Sin grupo</div>
                                        <div className="d-flex flex-column gap-2">
                                            {block.entries.map((entry, entryIdx) => renderEntry(entry, `b${idx}_${entryIdx}`))}
                                        </div>
                                    </div>
                                );
                            }
                            return null;
                        })}
                    </div>
                </div>
            </div>
        );
    };

    const SubstitutesModal = () => {
        const { substituteModal, closeSubstituteModal, applySubstitute, exerciseLookup, queue } = useWorkout();
        const [scope, setScope] = useState("remaining");

        useEffect(() => {
            if (substituteModal.isOpen) setScope("remaining");
        }, [substituteModal.isOpen]);

        if (!substituteModal.isOpen) return null;
        const step = queue[substituteModal.stepIndex];
        if (!step || step.type !== 'work') return null;

        const ex = getExerciseWithLookup(step.exercise || {}, exerciseLookup);
        const substitutes = resolveSubstitutes(
            ex.substitutes || ex.equivalents || ex.equivalent_exercises || [],
            exerciseLookup
        );

        return (
            <div className="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-black-trans animate-slide-up" style={{ zIndex: 2800 }}>
                <div className="card bg-black border border-secondary shadow-lg p-3" style={{ maxWidth: '95%', width: '420px', borderRadius: '16px' }}>
                    <div className="card-body text-white">
                        <div className="d-flex justify-content-between align-items-center mb-2">
                            <h5 className="fw-bold text-cyber-green m-0">Sustitutos</h5>
                            <button className="btn btn-sm btn-outline-secondary" onClick={closeSubstituteModal}>
                                <i className="fas fa-times"></i>
                            </button>
                        </div>
                        <div className="text-secondary small mb-3">Quick swap: elige un sustituto y aplica el cambio.</div>

                        <div className="mb-3">
                            <div className="text-uppercase text-secondary small mb-2">Aplicar a</div>
                            <div className="d-flex gap-3 flex-wrap">
                                <label className="form-check d-flex align-items-center gap-2">
                                    <input
                                        className="form-check-input"
                                        type="radio"
                                        name="swapScope"
                                        checked={scope === "current"}
                                        onChange={() => setScope("current")}
                                    />
                                    <span className="form-check-label">Solo esta serie</span>
                                </label>
                                <label className="form-check d-flex align-items-center gap-2">
                                    <input
                                        className="form-check-input"
                                        type="radio"
                                        name="swapScope"
                                        checked={scope === "remaining"}
                                        onChange={() => setScope("remaining")}
                                    />
                                    <span className="form-check-label">Series restantes</span>
                                </label>
                            </div>
                        </div>

                        {substitutes.length === 0 && (
                            <div className="text-secondary small">No hay sustitutos disponibles.</div>
                        )}

                        <div className="d-flex flex-column gap-2">
                            {substitutes.map((sub, idx) => {
                                const name = sub.exercise_name || sub.name || "Ejercicio";
                                const bodyPartLabel = translateBodyPart(sub.body_part);
                                const equipmentMeta = getEquipmentMeta(sub.equipment);
                                const hasVideo = sub.video_url && sub.video_url.trim() !== "";
                                return (
                                    <div key={`${sub._id || sub.id || idx}`} className="border border-secondary rounded p-2 bg-black-trans">
                                        <div className="d-flex justify-content-between align-items-start gap-2">
                                            <div>
                                                <div className="fw-bold text-white">{name}</div>
                                                <div className="text-secondary small d-flex flex-wrap gap-2 mt-1">
                                                    <span className="badge bg-secondary">{bodyPartLabel}</span>
                                                    <span className="badge bg-dark border border-secondary text-info">
                                                        <i className={`${equipmentMeta.icon} me-1`}></i>{equipmentMeta.label}
                                                    </span>
                                                </div>
                                            </div>
                                            <div className="d-flex flex-column gap-2">
                                                {hasVideo && (
                                                    <button
                                                        type="button"
                                                        className="btn btn-sm btn-outline-danger"
                                                        onClick={() => openVideoModal(sub.video_url)}
                                                    >
                                                        <i className="fab fa-youtube"></i>
                                                    </button>
                                                )}
                                                <button
                                                    type="button"
                                                    className="btn btn-sm btn-outline-success"
                                                    onClick={() => applySubstitute(sub, scope, substituteModal.stepIndex)}
                                                >
                                                    Usar
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const PreStart = ({ focusMode, onToggleFocus, showPending, onTogglePending }) => {
        const { routine, startWorkout } = useWorkout();
        return (
            <div className="player-container">
                <Header focusMode={focusMode} onToggleFocus={onToggleFocus} showPending={showPending} onTogglePending={onTogglePending} />
                <div className="visual-stage text-center">
                    <RoutineDetails routine={routine} />
                </div>
                <div className="controls-section">
                    <button className="btn btn-action shadow-lg ripple" onClick={startWorkout}>
                        INICIAR ENTRENAMIENTO <i className="fas fa-play ms-2"></i>
                    </button>
                </div>
            </div>
        );
    };

    const InputControls = ({ step, compact = false, hideRPE = false }) => {
        const { logSet, next, sessionLog, sessionLogRef, historyMaxByExercise } = useWorkout();
        // Local state for inputs so we can edit before committing
        const [weight, setWeight] = useState(step.target.weight || '');
        const [reps, setReps] = useState(step.target.reps || '');
        const [rpe, setRpe] = useState(8);
        const [unit, setUnit] = useState('lb');
        const [plateModalOpen, setPlateModalOpen] = useState(false);
        const [plateCounts, setPlateCounts] = useState({
            2.5: 0,
            5: 0,
            10: 0,
            25: 0,
            35: 0,
            45: 0
        });
        const [showTapHint, setShowTapHint] = useState(false);
        const [plateCountMode, setPlateCountMode] = useState('per_side');

        // Reset plates when modal opens or step changes
        useEffect(() => {
            if (plateModalOpen) {
                setPlateCounts({
                    2.5: 0, 5: 0, 10: 0, 25: 0, 35: 0, 45: 0
                });
                setIncludeBar(false); // Optional: also reset bar toggle? User asked to "reset to zero"
            }
        }, [plateModalOpen]);
        const [includeBar, setIncludeBar] = useState(false);
        const [barWeight, setBarWeight] = useState(20);
        const weightInputRef = useRef(null);
        const repsInputRef = useRef(null);
        const rpe8Ref = useRef(null);

        const plateOptions = [
            { value: 2.5, label: "2.5", src: "/static/images/disc/2_5.png" },
            { value: 5, label: "5", src: "/static/images/disc/5.png" },
            { value: 10, label: "10", src: "/static/images/disc/10.png" },
            { value: 25, label: "25", src: "/static/images/disc/25.png" },
            { value: 35, label: "35", src: "/static/images/disc/35.png" },
            { value: 45, label: "45", src: "/static/images/disc/45.png" }
        ];

        const plateMultiplier = plateCountMode === 'per_side' ? 2 : 1;
        const totalPlatesLb = plateOptions.reduce((acc, plate) => {
            const count = plateCounts[plate.value] || 0;
            return acc + (count * plate.value * plateMultiplier);
        }, 0);
        const totalWithBarLb = totalPlatesLb + (includeBar ? (parseFloat(barWeight) || 0) : 0);

        const applyPlateTotal = () => {
            const total = totalWithBarLb;
            let nextWeight = total;
            if (unit === 'kg') {
                nextWeight = total / 2.20462;
            }
            const rounded = Math.round(nextWeight * 10) / 10;
            setWeight(rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(1));
            setPlateModalOpen(false);
        };

        const updatePlateCount = (value, delta) => {
            setPlateCounts(prev => {
                const next = { ...prev };
                const nextVal = Math.max(0, (next[value] || 0) + delta);
                next[value] = nextVal;
                return next;
            });
        };

        // Pre-fill from history and AUTO-FOCUS
        const focusWeightInput = (selectAll = true) => {
            if (!weightInputRef.current) return false;
            weightInputRef.current.focus();
            if (selectAll) weightInputRef.current.select();
            return true;
        };

        useEffect(() => {
            const exerciseId = step.exercise?.exercise_id || step.exercise?._id || step.exercise?.id;
            let nextWeight = step.target.weight || '';
            let nextReps = step.target.reps || '';
            if (exerciseId || step.exercise?.name) {
                // Use Ref for immediate consistency, fallback to state
                const currentLog = (sessionLogRef && sessionLogRef.current) ? sessionLogRef.current : sessionLog;

                // Debug log
                console.log("InputControls: Searching log for", { exerciseId, name: step.exercise?.name, logLen: currentLog.length });

                const lastMatch = [...currentLog].reverse().find(entry => {
                    // Check exerciseId (camelCase) or exercise_id (snake_case)
                    const entryId = entry.exerciseId || entry.exercise_id;
                    if (exerciseId && entryId && String(entryId) === String(exerciseId)) return true;
                    // Fallback to name match if IDs fail
                    if (step.exercise?.name && entry.name === step.exercise.name) return true;
                    return false;
                });

                if (lastMatch) {
                    console.log("InputControls: Match found", lastMatch);
                    if (lastMatch.weight != null && lastMatch.weight !== '') nextWeight = lastMatch.weight;
                    if (lastMatch.reps) nextReps = lastMatch.reps;
                }
                if (!lastMatch && step.setNumber === 1) {
                    const historyMax = historyMaxByExercise[exerciseId];
                    if (historyMax != null && historyMax !== '') {
                        nextWeight = String(historyMax);
                    }
                }
            }
            if (unit === 'lb' && nextWeight !== '') {
                // Convert KG (from DB) to LB
                const valKg = parseFloat(nextWeight);
                if (!isNaN(valKg)) {
                    // Round to nearest 0.5 to match input behavior
                    const valLb = valKg * 2.20462;
                    const roundedLb = Math.round(valLb * 2) / 2;
                    nextWeight = roundedLb % 1 === 0 ? roundedLb.toString() : roundedLb.toFixed(1);
                }
            }

            setWeight(nextWeight);
            setReps(nextReps);
            setRpe(8);

            const shouldFocusWeight = !compact && step.type === 'work' && !step.isTimeBased && !step.target?.time;
            setShowTapHint(shouldFocusWeight);
            // If weight input is visible, focus/select it to speed entry.
            setTimeout(() => {
                if (shouldFocusWeight && focusWeightInput(true)) {
                    setShowTapHint(false);
                    return;
                }
                if (rpe8Ref.current) {
                    rpe8Ref.current.focus();
                    return;
                }
                if (document.activeElement && typeof document.activeElement.blur === "function") {
                    document.activeElement.blur();
                }
            }, 100);
            if (shouldFocusWeight) {
                setTimeout(() => {
                    if (focusWeightInput(true)) {
                        setShowTapHint(false);
                    }
                }, 350);
            }
        }, [step, sessionLog, historyMaxByExercise]);

        const adjustReps = (delta) => {
            const current = parseInt(reps, 10);
            const base = Number.isFinite(current) ? current : 0;
            const nextValue = Math.max(0, base + delta);
            setReps(String(nextValue));
        };

        const handleSubmit = () => {
            let finalWeight = parseFloat(weight) || 0;
            if (unit === 'lb') {
                finalWeight = finalWeight / 2.20462;
            }
            logSet({ weight: finalWeight.toFixed(1), reps, rpe });
            next();
        };

        // Expose submit handler via Ref if we were using a parent generic button, 
        // but cleaner to have the main button Context-aware or passed down. 
        // We'll use a specific ID based approach or shared state if needed.
        // BETTER: The MainButton is smart. It detects "Type". 



        const toggleUnit = () => {
            setUnit(prev => prev === 'kg' ? 'lb' : 'kg');
            const val = parseFloat(weight) || 0;
            if (val > 0) {
                let converted;
                if (unit === 'kg') {
                    // kg -> lb
                    converted = val * 2.20462;
                } else {
                    // lb -> kg
                    converted = val / 2.20462;
                }
                // Round to nearest 0.5
                const rounded = Math.round(converted * 2) / 2;
                // Remove decimal if .0, keep if .5
                setWeight(rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(1));
            }
        };

        const adjustWeight = (delta) => {
            let val = parseFloat(weight) || 0;
            const newVal = Math.max(0, val + delta);
            setWeight(newVal.toFixed(1));
        };

        const equivalentText = React.useMemo(() => {
            const val = parseFloat(weight) || 0;
            if (val === 0) return "";

            let converted;
            let targetUnit;
            if (unit === 'kg') {
                // Current is kg, show lb equivalent
                converted = val * 2.20462;
                targetUnit = 'lb';
            } else {
                converted = val / 2.20462;
                targetUnit = 'kg';
            }
            const rounded = Math.round(converted * 2) / 2;
            const displayVal = rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(1);
            return ` ${displayVal} ${targetUnit}`;
        }, [weight, unit]);

        return (
            <div className="py-1">
                <div className="row g-2 justify-content-center mb-2">
                    {!compact && (
                        <div className="col-6">
                            <div className="weight-header">
                                {!hideRPE && (
                                    <button
                                        type="button"
                                        className="plate-icon-btn"
                                        title="Calculadora de discos"
                                        onClick={() => setPlateModalOpen(true)}
                                    >
                                        <img src="/static/images/disc/45.png" alt="Disco" className="plate-icon-img" />
                                    </button>
                                )}
                                <div className="d-flex align-items-center justify-content-center gap-1">
                                    <label className="text-secondary small fw-bold m-0" style={{ fontSize: '0.7rem' }}>PESO</label>
                                    <button className="btn btn-sm btn-dark border border-secondary py-0 px-1 small font-monospace" onClick={toggleUnit} style={{ fontSize: '0.65rem' }}>
                                        {unit.toUpperCase()}
                                    </button>
                                </div>
                            </div>
                            <div className="d-flex align-items-center justify-content-center gap-1">
                                <button
                                    className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                    type="button"
                                    onClick={() => adjustWeight(unit === 'lb' ? -5 : -2.5)}
                                >-</button>
                                <div className="position-relative">
                                    <input
                                        key={`weight_${step.id}`}
                                        type="text"
                                        inputMode="decimal"
                                        pattern="[0-9]*[.,]?[0-9]*"
                                        ref={weightInputRef}
                                        className="form-control input-hud text-center p-0"
                                        value={weight}
                                        onChange={e => setWeight(e.target.value)}
                                        placeholder="0"
                                        onClick={(e) => e.target.select()}
                                        onFocus={() => setShowTapHint(false)}
                                        autoFocus={!compact && step.type === 'work' && !step.isTimeBased && !step.target?.time}
                                    />
                                    {showTapHint && (
                                        <button
                                            type="button"
                                            className="tap-hint-overlay"
                                            onClick={() => {
                                                if (weightInputRef.current) {
                                                    weightInputRef.current.focus();
                                                    weightInputRef.current.select();
                                                    setShowTapHint(false);
                                                }
                                            }}
                                        >
                                            Tocar para editar
                                        </button>
                                    )}
                                </div>
                                <button
                                    className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                    type="button"
                                    onClick={() => adjustWeight(unit === 'lb' ? 5 : 2.5)}
                                >+</button>
                            </div>
                            <div className="text-center text-muted small mt-1" style={{ fontSize: '0.7rem' }}>
                                {equivalentText}
                            </div>
                        </div>
                    )}
                    <div className={compact ? "col-12" : "col-6 reps-column"}>
                        <div className="reps-header">
                            <label className="text-secondary small fw-bold m-0" style={{ fontSize: '0.7rem' }}>
                                REPS {step.target.reps && <span className="text-cyber-green ms-1">({step.target.reps})</span>}
                            </label>
                        </div>
                        <div className="d-flex align-items-center justify-content-center gap-1">
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustReps(-1)}
                            >-</button>
                            <input
                                type="text"
                                ref={repsInputRef}
                                className="form-control input-hud text-center p-0"
                                value={reps}
                                onChange={e => setReps(e.target.value)}
                                placeholder="0"
                                inputMode="numeric"
                                pattern="[0-9\\-]*"
                                onClick={(e) => e.target.select()}
                            />
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustReps(1)}
                            >+</button>
                        </div>
                    </div>
                </div>

                {!compact && !hideRPE && (
                    <div className="mb-3">
                        <label className="text-secondary small fw-bold mb-1 d-block text-center" style={{ fontSize: '0.7rem' }}>RPE (1-10)</label>
                        <div className="d-flex justify-content-center gap-1">
                            {[7, 8, 9, 10].map(val => (
                                <button key={val}
                                    type="button"
                                    ref={val === 8 ? rpe8Ref : null}
                                    className={`btn btn-sm btn-rpe-hud d-flex align-items-center justify-content-center ${rpe === val ? 'btn-light' : 'btn-outline-secondary'}`}
                                    onClick={() => setRpe(val)}
                                >{val}</button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="d-grid px-3">
                    <button className="btn btn-action shadow-lg ripple py-3" onClick={handleSubmit}>
                        COMPLETAR <i className="fas fa-check ms-2"></i>
                    </button>
                </div>

                {plateModalOpen && (
                    <div className="plate-modal-backdrop" onClick={() => setPlateModalOpen(false)}>
                        <div className="plate-modal" onClick={(e) => e.stopPropagation()}>
                            <div className="plate-modal-header">
                                <div className="fw-bold">Discos (lb)</div>
                                <button className="btn btn-sm btn-outline-secondary" onClick={() => setPlateModalOpen(false)}>
                                    <i className="fas fa-times"></i>
                                </button>
                            </div>
                            <div className="plate-modal-body">
                                <div className="plate-mode-row">
                                    <div className="plate-mode-label">Conteo</div>
                                    <div className="btn-group btn-group-sm" role="group" aria-label="Conteo de discos">
                                        <button
                                            type="button"
                                            className={`btn ${plateCountMode === 'per_side' ? 'btn-info text-dark' : 'btn-outline-secondary'}`}
                                            onClick={() => setPlateCountMode('per_side')}
                                        >
                                            Por lado
                                        </button>
                                        <button
                                            type="button"
                                            className={`btn ${plateCountMode === 'total' ? 'btn-info text-dark' : 'btn-outline-secondary'}`}
                                            onClick={() => setPlateCountMode('total')}
                                        >
                                            Total
                                        </button>
                                    </div>
                                </div>
                                <div className="plate-grid">
                                    {plateOptions.map(plate => (
                                        <div key={plate.value} className="plate-tile">
                                            <img src={plate.src} alt={`${plate.label} lb`} />
                                            <div className="text-secondary small">{plate.label} lb</div>
                                            <div className="plate-counter">
                                                <button type="button" onClick={() => updatePlateCount(plate.value, -1)}>-</button>
                                                <div className="fw-bold text-theme" style={{ minWidth: '18px' }}>
                                                    {plateCounts[plate.value] || 0}
                                                </div>
                                                <button type="button" onClick={() => updatePlateCount(plate.value, 1)}>+</button>
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                <div className="mt-3 d-flex align-items-center justify-content-between">
                                    <div className="text-secondary small">
                                        Total discos {plateCountMode === 'per_side' ? '(por lado x2)' : '(total)'}
                                    </div>
                                    <div className="plate-total">{totalPlatesLb.toFixed(1)} lb</div>
                                </div>

                                <div className="mt-3 d-flex align-items-center justify-content-between">
                                    <div className="text-secondary small">Peso de barra</div>
                                    <div className="d-flex align-items-center gap-2">
                                        <div className="form-check form-switch m-0">
                                            <input
                                                className="form-check-input"
                                                type="checkbox"
                                                checked={includeBar}
                                                onChange={(e) => setIncludeBar(e.target.checked)}
                                            />
                                        </div>
                                        <input
                                            type="number"
                                            min="0"
                                            className="form-control form-control-sm border-secondary"
                                            style={{ width: '80px' }}
                                            value={barWeight}
                                            onChange={(e) => setBarWeight(e.target.value)}
                                            disabled={!includeBar}
                                        />
                                        <span className="text-secondary small">lb</span>
                                    </div>
                                </div>

                                <div className="mt-3 d-flex align-items-center justify-content-between">
                                    <div className="text-secondary small">Total</div>
                                    <div className="plate-total">{totalWithBarLb.toFixed(1)} lb</div>
                                </div>
                            </div>
                            <div className="plate-modal-footer">
                                <button className="btn btn-outline-secondary" onClick={() => setPlateModalOpen(false)}>
                                    Cancelar
                                </button>
                                <button className="btn btn-info text-dark fw-bold" onClick={applyPlateTotal}>
                                    Aplicar
                                </button>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    };

    const TimerControls = ({ step }) => {
        const { stepTimer, isTimerRunning, setIsTimerRunning, next, logSet } = useWorkout();

        const toggle = () => setIsTimerRunning(!isTimerRunning);
        const finish = () => {
            logSet({
                time_seconds: step.target.time
            });
            next();
        }

        return (
            <div className="text-center py-4">
                <div className="display-1 fw-bold text-theme mb-2 font-monospace" style={{ textShadow: '0 0 20px rgba(0,0,0,0.1)' }}>
                    {formatTime(stepTimer)}
                </div>
                <p className="text-success mb-4">TIEMPO OBJETIVO</p>

                <div className="d-grid gap-2">
                    {!isTimerRunning && stepTimer > 0 && (
                        <button className="btn btn-action" onClick={toggle}>INICIAR <i className="fas fa-play ms-2"></i></button>
                    )}
                    {isTimerRunning && (
                        <button className="btn btn-outline-light py-3 border-2" onClick={toggle}>PAUSA ||</button>
                    )}
                    <button className="btn btn-outline-secondary btn-sm mt-3" onClick={finish}>Terminar Manualmente</button>
                </div>
            </div>
        );
    };

    const RestOverlay = ({ nextStep, showPending, onTogglePending }) => {
        const { currentStep, skipRest, stepTimer } = useWorkout();

        if (currentStep.type !== 'rest') return null;

        if (currentStep.type !== 'rest') return null;

        const isLastStep = !nextStep;
        const nextExName = isLastStep ? "Fin de la Rutina" : (nextStep?.exercise?.name || nextStep?.exercise?.exercise_name || "Siguiente Ejercicio");
        // Check for comment/note/description
        const nextNote = nextStep?.exercise?.comment || nextStep?.exercise?.note || nextStep?.exercise?.description || "";
        const isNextTimeBased = nextStep?.isTimeBased || false; // Or check type

        return (
            <div className="rest-overlay position-fixed top-0 start-0 w-100 h-100 d-flex flex-column justify-content-center align-items-center p-4" style={{ zIndex: 2000, backgroundColor: 'var(--bg-body)' }}>
                <div className="position-absolute top-0 end-0 p-3">
                    <div className="d-flex align-items-center gap-2">
                        <button
                            className="btn btn-sm btn-outline-secondary rounded-circle"
                            onClick={() => window.toggleTheme && window.toggleTheme()}
                            title="Cambiar Tema"
                        >
                            <i className="fas fa-adjust"></i>
                        </button>
                        <button
                            className={`btn btn-sm rounded-pill px-3 ${showPending ? 'btn-info text-dark' : 'btn-outline-info'}`}
                            onClick={onTogglePending}
                            title="Pendientes"
                        >
                            <i className="fas fa-list"></i>
                        </button>
                    </div>
                </div>
                <div className="text-center mb-5">
                    <h2 className="display-1 fw-bold mb-0 text-success font-monospace">{formatTime(stepTimer)}</h2>
                    <p className="text-secondary text-uppercase letter-spacing-2 mt-2">Descanso</p>
                </div>

                <div className="text-center mb-5 animate-pulse">
                    <p className="text-muted small mb-2 text-uppercase">A continuacin</p>
                    <h3 className="h2 fw-bold mb-3">{nextExName}</h3>
                    {nextNote && (
                        <div className="alert alert-dark border-secondary text-info d-inline-block px-4 py-2" style={{ maxWidth: '90%' }}>
                            <i className="fas fa-info-circle me-2"></i>{nextNote}
                        </div>
                    )}
                </div>

                <button className="btn btn-outline-secondary rounded-pill px-5 py-3" onClick={skipRest}>
                    SALTAR DESCANSO <i className="fas fa-forward ms-2"></i>
                </button>
            </div>
        );
    };

    const ActiveExercise = ({ focusMode }) => {
        const { currentStep, exerciseLookup, openSubstituteModal } = useWorkout();

        if (!currentStep || currentStep.type !== 'work' || !currentStep.exercise) return null;
        const ex = getExerciseWithLookup(currentStep.exercise || {}, exerciseLookup);
        const name = ex.exercise_name || ex.name || 'Ejercicio';
        const bodyPart = translateBodyPart(ex.body_part);
        const hasVideo = ex.video_url && ex.video_url.trim() !== "";
        const substitutes = resolveSubstitutes(
            ex.substitutes || ex.equivalents || ex.equivalent_exercises || [],
            exerciseLookup
        );
        const exerciseComment = ex.comment || ex.note || ex.description || "";
        const groupComment = currentStep.groupComment || "";

        if (focusMode) {
            return (
                <div className={`active-card ${currentStep.isTimeBased ? 'time-mode' : ''} animate-entry d-flex flex-column h-100`}>
                    <div className="d-flex flex-column justify-content-between h-100">
                        <div className="text-center mb-2">
                            <div className="text-info fs-6 mb-1">
                                Serie <span className="text-white fw-bold">{currentStep.setNumber}</span> / <span className="text-secondary">{currentStep.totalSets}</span>
                            </div>
                            <h2 className="fw-bold text-white m-0 heading-wrap">{name}</h2>
                            {currentStep.isTimeBased && (
                                <div className="text-secondary small mt-1">Tiempo objetivo: {Math.round((currentStep.target?.time || 0) / 60)} min</div>
                            )}
                            {currentStep.isTimeBased && (
                                <div className="text-secondary small mt-1">Tiempo objetivo: {Math.round((currentStep.target?.time || 0) / 60)} min</div>
                            )}
                        </div>
                        <div className="flex-grow-1 d-flex flex-column justify-content-center">
                            {currentStep.isTimeBased ? (
                                <TimerControls step={currentStep} />
                            ) : (
                                <InputControls key={currentStep.id} step={currentStep} hideRPE />
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        return (
            <div className={`active-card ${currentStep.isTimeBased ? 'time-mode' : ''} animate-entry d-flex flex-column h-100`}>
                <div className="d-flex flex-column justify-content-between h-100">

                    {/* Header Part */}
                    <div className="text-center mobile-compact-mb mb-3">
                        {currentStep.groupName && (
                            <div className="mb-1">
                                <span className="badge bg-danger px-2 py-1 small">{currentStep.groupName}</span>
                            </div>
                        )}
                        <span className="text-secondary text-uppercase small tracking-widest d-block mb-1" style={{ fontSize: '0.7rem' }}>{bodyPart}</span>

                        <div className="d-flex flex-column align-items-center justify-content-center gap-1">
                            <h2 className="fw-bold text-white m-0 heading-wrap">{name}</h2>
                            <div className="d-flex flex-wrap align-items-center justify-content-center gap-2">
                                {hasVideo && (
                                    <button
                                        type="button"
                                        className="btn btn-sm btn-outline-danger rounded-pill px-3 py-0"
                                        style={{ fontSize: '0.75rem' }}
                                        onClick={() => openVideoModal(ex.video_url)}
                                    >
                                        <i className="fab fa-youtube me-1"></i> Tutorial
                                    </button>
                                )}
                                {substitutes.length > 0 && (
                                    <button
                                        type="button"
                                        className="btn btn-sm btn-outline-info rounded-pill px-3 py-0"
                                        style={{ fontSize: '0.75rem' }}
                                        onClick={() => openSubstituteModal()}
                                    >
                                        <i className="fas fa-exchange-alt me-1"></i> Sustitutos
                                    </button>
                                )}
                            </div>
                        </div>
                        <div className="mt-1 text-info fs-6">
                            Serie <span className="text-white fw-bold">{currentStep.setNumber}</span> / <span className="text-secondary">{currentStep.totalSets}</span>
                        </div>
                    </div>

                    {/* Controls Part */}
                    <div className="flex-grow-1 d-flex flex-column justify-content-center">
                        {currentStep.isTimeBased ? (
                            <TimerControls step={currentStep} />
                        ) : (
                            <InputControls key={currentStep.id} step={currentStep} />
                        )}
                    </div>

                    {/* Footer Part */}
                    {(groupComment || exerciseComment) && (
                        <div className="mt-2 pt-2 border-top border-secondary text-center">
                            {groupComment && <div className="text-cyber-orange small">{groupComment}</div>}
                            {exerciseComment && <div className="text-secondary small">{exerciseComment}</div>}
                        </div>
                    )}
                </div>
            </div>
        );
    };



    const NextUpBar = () => {
        const { queue, cursor, status } = useWorkout();
        if (status === 'LOADING' || status === 'IDLE' || status === 'FINISHED') return null;

        let idx = cursor + 1;
        while (idx < queue.length && queue[idx].type !== 'work') {
            idx += 1;
        }
        if (idx >= queue.length) {
            return (
                <div className="px-3 pb-2 text-center w-100">
                    <div className="d-inline-flex align-items-center justify-content-center gap-2 py-1 px-3 rounded-pill border border-success"
                        style={{
                            opacity: 0.9,
                            maxWidth: '95%',
                            backgroundColor: 'var(--bg-card)', // Use theme variable
                            color: 'var(--text-main)', // Use theme variable
                            boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
                        }}>
                        <span className="text-secondary text-uppercase flex-shrink-0" style={{ fontSize: '0.7rem', letterSpacing: '1px' }}>Siguiente</span>
                        <span className="text-success fw-bold text-truncate" style={{ fontSize: '0.8rem', maxWidth: '60vw' }}>Fin de la Rutina</span>
                        <i className="fas fa-flag-checkered text-success ms-1"></i>
                    </div>
                </div>
            );
        }

        let restInfo = "";
        const restIdx = cursor + 1;
        if (restIdx < queue.length && queue[restIdx].type === 'rest') {
            const restStep = queue[restIdx];
            restInfo = `${restStep.duration || 0}s`;
        }

        const ex = queue[idx].exercise || {};
        const name = ex.exercise_name || ex.name || "Ejercicio";
        return (
            <div className="px-3 pb-2 text-center w-100">
                <div className="d-inline-flex align-items-center justify-content-center gap-2 py-1 px-3 rounded-pill bg-black-trans border border-dark" style={{ opacity: 0.7, maxWidth: '95%' }}>
                    <span className="text-secondary text-uppercase flex-shrink-0" style={{ fontSize: '0.7rem', letterSpacing: '1px' }}>Siguiente</span>
                    <span className="text-light fw-bold text-truncate" style={{ fontSize: '0.8rem', maxWidth: '60vw' }}>{name}</span>
                    {restInfo && <span className="text-muted flex-shrink-0" style={{ fontSize: '0.7rem' }}>({restInfo})</span>}
                </div>
            </div>
        );
    };

    const PendingPanel = ({ isOpen, onClose }) => {
        const { queue, cursor, status } = useWorkout();
        if (status === 'LOADING' || status === 'IDLE' || status === 'FINISHED') return null;

        const pendingSteps = queue.slice(cursor + 1).filter(step => step.type === 'work');

        return (
            <>
                <div className={`pending-backdrop ${isOpen ? 'show' : ''}`} onClick={onClose}></div>
                <div className={`pending-panel ${isOpen ? 'open' : ''}`}>
                    <div className="pending-panel-header">
                        <div className="fw-bold text-white">Pendientes</div>
                        <button className="btn btn-sm btn-outline-secondary" onClick={onClose}>
                            <i className="fas fa-times"></i>
                        </button>
                    </div>
                    <div className="pending-panel-body">
                        {pendingSteps.length === 0 && (
                            <div className="text-secondary small">No hay ejercicios pendientes.</div>
                        )}
                        {pendingSteps.map((step, idx) => {
                            const ex = step.exercise || {};
                            const name = ex.exercise_name || ex.name || 'Ejercicio';
                            const target = step.isTimeBased
                                ? `${Math.round((step.target?.time || 0))}s`
                                : (step.target?.reps || '-');
                            const setsLabel = `${step.setNumber}/${step.totalSets}`;
                            return (
                                <div key={`${step.id}_${idx}`} className="border border-secondary rounded p-2 mb-2 bg-black-trans">
                                    <div className="d-flex justify-content-between align-items-start">
                                        <div>
                                            <div className="text-white fw-bold">{name}</div>
                                            {step.groupName && (
                                                <div className="text-cyber-orange small">{step.groupName}</div>
                                            )}
                                        </div>
                                        <div className="text-secondary small text-end">
                                            <div>Serie {setsLabel}</div>
                                            <div>{step.isTimeBased ? `Tiempo ${target}` : `Reps ${target}`}</div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </>
        );
    };

    const Header = ({ focusMode, onToggleFocus, showPending, onTogglePending }) => {
        const { routine, globalTime, cursor, queue, isPaused, togglePause, cancelWorkout, status, startWorkout } = useWorkout();

        // Calculate Work Steps only
        const workStats = React.useMemo(() => {
            const total = queue.filter(s => s.type === 'work').length;
            // Include current if it is work, or count up to this point
            const passed = queue.slice(0, cursor + 1).filter(s => s.type === 'work').length;
            return { passed, total };
        }, [cursor, queue]);

        return (
            <div className="header-section d-flex justify-content-between align-items-center p-3 relative">
                {/* Left: Info */}
                <div className="header-info d-flex align-items-center gap-3" style={{ flex: 1 }}>
                    <a href="/dashboard" className="btn btn-sm btn-outline-secondary rounded-circle" title="Volver al Dashboard">
                        <i className="fas fa-arrow-left"></i>
                    </a>
                    <div style={{ minWidth: 0 }}>
                        <h5 className="m-0 fw-bold text-theme text-truncate" style={{ fontSize: '1rem' }}>{routine.name}</h5>
                        <div className="text-secondary small text-truncate">
                            Serie {workStats.passed} / {workStats.total}
                        </div>
                    </div>
                </div>

                {/* Center: Global Timer */}
                <div className="header-timer position-absolute start-50 top-50 translate-middle mobile-compact-timer">
                    <div className="font-monospace fs-3 text-cyber-green fw-bold bg-black px-3 rounded-pill border border-secondary shadow-sm">
                        {formatTime(globalTime)}
                    </div>
                </div>

                {/* Right: Controls */}
                <div className="header-controls d-flex align-items-center gap-2" style={{ flex: 1, justifyContent: 'flex-end' }}>
                    {/* Theme Toggle */}
                    <button
                        className="btn btn-sm btn-outline-secondary rounded-circle"
                        onClick={() => window.toggleTheme && window.toggleTheme()}
                        title="Cambiar Tema"
                    >
                        <i className="fas fa-adjust"></i>
                    </button>

                    {status !== 'IDLE' && status !== 'FINISHED' && (
                        <button
                            className={`btn btn-sm rounded-pill px-3 ${showPending ? 'btn-info text-dark' : 'btn-outline-info'}`}
                            onClick={onTogglePending}
                            title="Pendientes"
                        >
                            <i className="fas fa-list"></i>
                        </button>
                    )}
                    <button
                        className={`btn btn-sm rounded-pill px-3 ${focusMode ? 'btn-warning text-dark' : 'btn-outline-warning'}`}
                        onClick={onToggleFocus}
                        title="Modo foco"
                    >
                        <i className="fas fa-bullseye"></i>
                    </button>
                    {status === 'IDLE' ? (
                        <button className="btn btn-sm btn-outline-success rounded-pill px-3" onClick={startWorkout}>
                            <i className="fas fa-play"></i>
                        </button>
                    ) : (
                        <button className="btn btn-sm btn-outline-primary rounded-pill px-3" onClick={togglePause}>
                            <i className={`fas ${isPaused ? 'fa-play' : 'fa-pause'}`}></i>
                        </button>
                    )}
                    <button className="btn btn-sm btn-outline-danger rounded-circle" onClick={cancelWorkout} style={{ width: '32px', height: '32px', padding: 0 }}>
                        <i className="fas fa-times"></i>
                    </button>
                </div>
            </div>
        );
    };

    const NavigationWrapper = ({ children }) => {
        const { prev, skipToNextWork, showMessage, showConfirm } = useWorkout();

        const handleSkip = () => {
            showConfirm("Saltar Serie", "Seguro que quieres omitir esta serie?", () => {
                showMessage("Set omitido", "info");
                skipToNextWork();
            }, "warning");
        };

        return (
            <div className="d-flex w-100 h-100 align-items-center justify-content-center position-relative">

                {/* Desktop Prev (Left) */}
                <div className="d-none d-md-block me-3">
                    <button className="btn btn-outline-secondary rounded-circle p-3" onClick={prev} style={{ width: '60px', height: '60px' }}>
                        <i className="fas fa-chevron-left fa-lg"></i>
                    </button>
                </div>

                {/* Main Content */}
                <div className="flex-grow-1 d-flex flex-column align-items-center justify-content-center w-100" style={{ maxWidth: '600px' }}>
                    {children}

                    {/* Mobile Navigation (Bottom of Card) */}
                    <div className="d-flex d-md-none w-100 justify-content-between px-3 mt-3">
                        <button className="btn btn-link text-secondary text-decoration-none" onClick={prev}>
                            <i className="fas fa-chevron-left me-1"></i> Anterior
                        </button>
                        <button className="btn btn-link text-secondary text-decoration-none" onClick={handleSkip}>
                            Saltar <i className="fas fa-chevron-right ms-1"></i>
                        </button>
                    </div>
                </div>

                {/* Desktop Skip (Right) */}
                <div className="d-none d-md-block ms-3">
                    <button className="btn btn-outline-secondary rounded-circle p-3" onClick={handleSkip} style={{ width: '60px', height: '60px' }}>
                        <i className="fas fa-chevron-right fa-lg"></i>
                    </button>
                </div>
            </div>
        );
    };

    // --- MAIN APP ---
    const App = () => {
        const { currentStep, status, queue, cursor, showCompletionIcon, showCountdown, countdownValue } = useWorkout();
        const [focusMode, setFocusMode] = useState(false);
        const [showPending, setShowPending] = useState(false);

        // Calculate next work step for preview
        const nextStep = React.useMemo(() => {
            if (!queue || cursor >= queue.length - 1) return null;
            // Find next WORK step
            return queue.slice(cursor + 1).find(s => s.type === 'work');
        }, [queue, cursor]);

        if (status === 'LOADING') return <div className="text-center text-white py-5">Cargando Motor...</div>;

        return (
            <>
                {/* Countdown Overlay */}
                <div className={`countdown-overlay ${showCountdown ? 'show' : ''}`}>
                    <img src="/static/images/icon/stw.png" alt="Get Ready" className="countdown-image" />
                    <div className="countdown-text">
                        00:0{countdownValue}
                    </div>
                </div>

                {/* Completion Overlay */}
                <div className={`completion-overlay ${showCompletionIcon ? 'show' : ''}`}>
                    <img src="/static/images/icon/fw.png" alt="Finished" className="completion-icon" />
                </div>

                {status === 'IDLE' ? (
                    <PreStart
                        focusMode={focusMode}
                        onToggleFocus={() => setFocusMode(prev => !prev)}
                        showPending={showPending}
                        onTogglePending={() => setShowPending(prev => !prev)}
                    />
                ) : status === 'FINISHED' ? (
                    <div className="d-flex flex-column h-100 justify-content-center align-items-center text-success">
                        <h1>Entrenamiento Completado!</h1>
                        <p>Guardando...</p>
                    </div>
                ) : (
                    <div className={`player-container ${focusMode ? "focus-mode" : ""}`}>
                        <Header
                            focusMode={focusMode}
                            onToggleFocus={() => setFocusMode(prev => !prev)}
                            showPending={showPending}
                            onTogglePending={() => setShowPending(prev => !prev)}
                        />

                        <div className="visual-stage">
                            {!focusMode && <MessageBar />}
                            {!focusMode && <NextUpBar />}
                            <NavigationWrapper>
                                {currentStep && <ActiveExercise focusMode={focusMode} />}
                            </NavigationWrapper>
                        </div>

                        {(status === 'WORK' || status === 'REST') && (
                            <PendingPanel isOpen={showPending} onClose={() => setShowPending(false)} />
                        )}

                        <RestOverlay
                            nextStep={nextStep}
                            showPending={showPending}
                            onTogglePending={() => setShowPending(prev => !prev)}
                        />
                        <SubstitutesModal />
                        <ConfirmModal />
                    </div>
                )}
            </>
        );
    };

    const Root = () => (
        <WorkoutProvider routine={INITIAL_ROUTINE}>
            <App />
        </WorkoutProvider>
    );

    // Mount
    const root = ReactDOM.createRoot(document.getElementById('react-root'));
    root.render(<Root />);
</script>
{% endraw %}
{% endblock %}