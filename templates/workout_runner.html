{% extends 'layout.html' %}

{% block title %}Smart Runner - AI Fitness{% endblock %}

{% block sidebar %}{% endblock %}

{% block content %}
<!-- React Root (Replaces old static HTML) -->
<div id="react-root" class="h-100"></div>

<!-- Modal Video -->
<div class="modal fade" id="videoModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content bg-black text-white border border-secondary">
            <div class="modal-header border-secondary">
                <h5 class="modal-title text-cyber-green">Video</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-0">
                <div class="ratio ratio-16x9">
                    <iframe id="videoFrame" src="" title="Video ejercicio"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
            </div>
            <div class="modal-footer border-secondary">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
            </div>
        </div>
    </div>
</div>

<!-- STYLES -->
<style>
    /* Zero-Scroll Native Layout */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        background-color: #000 !important;
        color: white;
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        height: 100dvh;
        /* Dynamic Viewport Height */
        width: 100vw;
        overflow: hidden;
        /* Prevent body scroll */
        overscroll-behavior: none;
        /* No bounce */
    }

    #react-root {
        height: 100%;
        width: 100%;
    }

    /* Main Flex Container */
    .player-container {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: #000;
    }

    /* 1. HEADER (Fixed) */
    .header-section {
        flex: 0 0 auto;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
    }

    /* 2. VISUAL STAGE (Flexible) */
    .visual-stage {
        flex: 1 1 auto;
        position: relative;
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow-y: auto;
        /* Internal scroll if needed */
        overflow-x: hidden;
        perspective: 1000px;
        padding: 1rem;
    }

    /* 3. CONTROLS (Fixed Bottom) */
    .controls-section {
        flex: 0 0 auto;
        background: #111;
        border-top: 1px solid #333;
        padding: 15px;
        padding-bottom: calc(15px + env(safe-area-inset-bottom));
        z-index: 20;
    }

    /* Component Styles */
    .active-card {
        width: 100%;
        max-width: 600px;
        background: #1a1a1a;
        border: 2px solid #333;
        border-radius: 24px;
        padding: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
    }

    .active-card.time-mode {
        border-color: #00ff9d;
        box-shadow: 0 0 20px rgba(0, 255, 157, 0.15);
    }

    /* Typography & Utilities */
    .text-cyber-green {
        color: #00ff9d !important;
    }

    .text-cyber-orange {
        color: #ff9d00 !important;
    }

    .input-hud {
        background: #000;
        border: 1px solid #333;
        color: white;
        font-family: 'Courier New', monospace;
        font-size: 2rem;
        text-align: center;
        border-radius: 12px;
        height: 60px;
    }

    .input-hud:focus {
        border-color: #00ff9d;
        outline: none;
        box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
    }

    .btn-action {
        background: #00E676;
        /* Vibrant Green */
        color: #000;
        font-weight: 800;
        text-transform: uppercase;
        border: none;
        border-radius: 50px;
        font-size: 1.1rem;
        letter-spacing: 1px;
        padding: 16px;
        width: 100%;
        box-shadow: 0 4px 15px rgba(0, 230, 118, 0.4);
        transition: transform 0.1s;
    }

    .btn-action:active {
        transform: scale(0.98);
    }

    /* Animations */
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animate-entry {
        animation: slideIn 0.3s ease-out forwards;
    }

    .animate-slide-up {
        animation: slideIn 0.4s ease-out forwards;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
    }

    .animate-fade-in {
        animation: fadeIn 0.3s ease-out forwards;
    }

    @media (max-width: 768px) {
        .active-card {
            padding: 0.75rem;
            /* Reduced padding */
            border-radius: 16px;
        }

        .input-hud {
            font-size: 1.2rem;
            /* reduced from 1.5rem */
            height: 40px;
            /* reduced from 50px */
        }

        .btn-action {
            padding: 10px;
            /* reduced from 14px */
            font-size: 0.9rem;
            /* reduced from 1rem */
        }

        .btn-control-hud {
            width: 36px !important;
            height: 36px !important;
        }

        .btn-rpe-hud {
            width: 40px !important;
            height: 36px !important;
            font-size: 0.8rem !important;
            padding: 0 !important;
        }
    }

    .btn-control-hud {
        width: 44px;
        height: 44px;
    }

    .btn-rpe-hud {
        width: 50px;
        height: 40px;
    }


    .heading-wrap {
        white-space: normal;
        /* Allow wrapping */
        word-wrap: break-word;
        /* Break long words if necessary */
        line-height: 1.1;
        /* Adjust line height for readability */
        font-size: clamp(1.2rem, 5vw, 2.2rem);
        /* Responsive font size */
    }
</style>


<!-- DEPENDENCIES (CDN) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- REACT APP -->
<script>
    // Inject server-side data from Jinja OUTSIDE the raw block
    window.initialRoutine = {{ routine | tojson }};
    window.currentUserName = {{ current_user_name | default ('', true) | tojson }};
    window.currentUserId = {{ current_user_id | default ('', true) | tojson }};
</script>

{% raw %}
<script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback, createContext, useContext } = React;

    // --- MOCK DATA / INJECTED DATA ---
    const INITIAL_ROUTINE = window.initialRoutine;
    const CURRENT_USER_NAME = window.currentUserName;
    const CURRENT_USER_ID = window.currentUserId;

    // --- HELPERS ---
    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${m}:${s}`;
    };

    const getAudio = () => {
        return new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
    };

    const getReturnUrl = () => {
        const params = new URLSearchParams(window.location.search);
        // Default to home if no specific return_to is provided
        return params.get('return_to') || '/';
    };

    if (CURRENT_USER_ID) {
        try {
            localStorage.setItem("ai_fitness_uid", CURRENT_USER_ID);
        } catch (e) { }
    }

    const EQUIPMENT_MAP = {
        barbell: { label: "Barra", icon: "fas fa-grip-lines" },
        dumbbell: { label: "Mancuernas", icon: "fas fa-dumbbell" },
        machine: { label: "Maquina", icon: "fas fa-cogs" },
        cable: { label: "Polea", icon: "fas fa-wave-square" },
        bodyweight: { label: "Corporal", icon: "fas fa-running" },
        other: { label: "Otro", icon: "fas fa-toolbox" }
    };

    let BODY_PART_MAP = {};

    const translateBodyPart = (bp) => {
        return BODY_PART_MAP[bp] || bp || "N/A";
    };

    const getEquipmentMeta = (equipmentKey) => {
        return EQUIPMENT_MAP[equipmentKey] || { label: equipmentKey || "N/A", icon: "fas fa-dumbbell" };
    };

    const toEmbedUrl = (url) => {
        const trimmed = (url || "").trim();
        if (!trimmed) return "";
        if (trimmed.includes("youtube.com/watch")) {
            const match = trimmed.match(/[?&]v=([^&]+)/);
            if (match && match[1]) return `https://www.youtube.com/embed/${match[1]}`;
        }
        if (trimmed.includes("youtu.be/")) {
            const match = trimmed.match(/youtu\.be\/([^?&]+)/);
            if (match && match[1]) return `https://www.youtube.com/embed/${match[1]}`;
        }
        return trimmed;
    };

    const openVideoModal = (url) => {
        const modalEl = document.getElementById("videoModal");
        const iframe = document.getElementById("videoFrame");
        const embedUrl = toEmbedUrl(url);
        if (!embedUrl) return;
        iframe.src = embedUrl;
        const modal = new bootstrap.Modal(modalEl);
        modal.show();
        modalEl.addEventListener("hidden.bs.modal", () => {
            iframe.src = "";
        }, { once: true });
    };

    const resolveSubstitutes = (substitutes, exerciseLookup) => {
        if (!substitutes || substitutes.length === 0) return [];
        return substitutes
            .map(sub => {
                if (typeof sub === "string") return exerciseLookup[sub];
                if (sub && typeof sub === "object") return sub;
                return null;
            })
            .filter(Boolean);
    };

    const getRestSeconds = (item) => {
        if (!item) return 60;
        if (item.rest_seconds != null) return item.rest_seconds;
        if (item.rest != null && item.rest !== item.target_time_seconds) return item.rest;
        return 60;
    };

    // --- ENGINE / STATE MACHINE ---

    /**
     * FLATTENS the routine into a linear "Playlist" or Queue of Steps.
     * This handles the complex logic of Circuits/Supersets upfront.
     *
     * Resulting Step Structure:
     * {
     *   id: string,
     *   type: 'work' | 'rest' | 'prep',
     *   exercise: object,
     *   setNumber: number,
     *   totalSets: number,
     *   isTimeBased: boolean,
     *   target: { weight?, reps?, time? },
     *   restAfter: number
     * }
     */
    const buildQueue = (routine) => {
        const queue = [];
        const items = Array.isArray(routine.items) ? routine.items : [];
        const isRestItem = (item) => item && (item.item_type === 'rest' || (!item.exercise_id && item.rest_seconds != null));
        const isExerciseItem = (item) => item && item.item_type === 'exercise';
        const isGroupItem = (item) => item && item.item_type === 'group';
        const groupMeta = new Map();

        items.filter(isGroupItem).forEach(group => {
            groupMeta.set(group._id, {
                name: group.group_name || group.name || 'Grupo',
                note: group.note || ''
            });
        });

        const pushRest = (restItem, key) => {
            queue.push({
                id: `rest_${key}_${queue.length}`,
                type: 'rest',
                duration: parseInt(getRestSeconds(restItem)),
                label: restItem.note || 'Descansar'
            });
        };

        const pushWorkStep = (ex, key, setNumber, totalSets, groupInfo) => {
            const exType = (ex.exercise_type || ex.type);
            const hasTimeTarget = ex.target_time_seconds != null || ex.time_seconds != null || ex.time != null;
            const hasRepsTarget = ex.target_reps != null || ex.reps != null;
            const isTime = exType === 'time' || exType === 'cardio' || (hasTimeTarget && !hasRepsTarget);
            queue.push({
                id: `step_${key}_${setNumber}`,
                type: 'work',
                exercise: ex,
                groupName: groupInfo ? groupInfo.name : null,
                groupComment: groupInfo ? groupInfo.note : null,
                setNumber,
                totalSets,
                isTimeBased: isTime,
                target: {
                    weight: ex.weight,
                    reps: ex.target_reps || ex.reps,
                    time: ex.target_time_seconds || ex.time_seconds || ex.time || 60
                }
            });
        };

        const addStraightSets = (ex, key, groupInfo) => {
            const exSets = parseInt(ex.target_sets || ex.sets || 1);
            for (let s = 1; s <= exSets; s++) {
                pushWorkStep(ex, key, s, exSets, groupInfo);
                if (s < exSets) {
                    queue.push({ type: 'rest', duration: parseInt(getRestSeconds(ex)), label: 'Descansar' });
                }
            }
        };

        const hasEmbeddedGroups = items.some(item => Array.isArray(item.items));
        if (hasEmbeddedGroups) {
            items.forEach((group, gIdx) => {
                if (isGroupItem(group) && !Array.isArray(group.items)) return;
                if (isRestItem(group)) {
                    pushRest(group, gIdx);
                    return;
                }

                const entries = Array.isArray(group.items) ? group.items : [group];
                const exerciseEntries = entries.filter(isExerciseItem);
                const restEntries = entries.filter(isRestItem);
                if (!exerciseEntries.length && restEntries.length) {
                    restEntries.forEach((restItem, rIdx) => pushRest(restItem, `${gIdx}_${rIdx}`));
                    return;
                }

                const isCircuit = group.item_type === 'group' || (group.items && group.items.length > 1);
                const maxSets = Math.max(...exerciseEntries.map(ex => parseInt(ex.target_sets || ex.sets || 1)));
                const groupInfo = {
                    name: group.name || group.group_name || 'Circuito',
                    note: group.note || ''
                };

                for (let s = 1; s <= maxSets; s++) {
                    entries.forEach((entry, exIdx) => {
                        if (isRestItem(entry)) {
                            pushRest(entry, `${gIdx}_${exIdx}_${s}`);
                            return;
                        }
                        if (!isExerciseItem(entry)) return;
                        const exSets = parseInt(entry.target_sets || entry.sets || 1);
                        if (s <= exSets) {
                            pushWorkStep(entry, `${gIdx}_${exIdx}`, s, exSets, groupInfo);

                            const isLastInCircuit = exIdx === entries.length - 1;
                            const isLastSet = s === maxSets;
                            const restTime = parseInt(getRestSeconds(entry));

                            if (isCircuit) {
                                if (isLastInCircuit && !isLastSet) {
                                    queue.push({ type: 'rest', duration: restTime, label: 'Descansar (Fin de Circuito)' });
                                }
                            } else if (!isLastSet) {
                                queue.push({ type: 'rest', duration: restTime, label: 'Descansar' });
                            }
                        }
                    });
                }
            });
        } else {
            const groupEntries = new Map();
            const blocks = [];
            const blockIds = new Set();

            const ensureGroupBlock = (groupId) => {
                if (!groupId || blockIds.has(groupId)) return;
                blockIds.add(groupId);
                blocks.push({ type: 'group', id: groupId });
            };

            items.forEach((item, idx) => {
                if (isGroupItem(item)) {
                    ensureGroupBlock(item._id);
                    return;
                }
                if (!isExerciseItem(item) && !isRestItem(item)) return;

                if (item.group_id) {
                    ensureGroupBlock(item.group_id);
                    if (!groupEntries.has(item.group_id)) groupEntries.set(item.group_id, []);
                    groupEntries.get(item.group_id).push(item);
                    return;
                }

                blocks.push({ type: 'entry', entry: item, key: `ungrouped_${idx}` });
            });

            const processedGroups = new Set();
            blocks.forEach((block) => {
                if (block.type === 'entry') {
                    const entry = block.entry;
                    if (isRestItem(entry)) {
                        pushRest(entry, block.key);
                    } else if (isExerciseItem(entry)) {
                        addStraightSets(entry, block.key, null);
                    }
                    return;
                }

                if (processedGroups.has(block.id)) return;
                processedGroups.add(block.id);
                const entries = groupEntries.get(block.id) || [];
                if (!entries.length) return;

                const exerciseEntries = entries.filter(isExerciseItem);
                const restEntries = entries.filter(isRestItem);
                if (!exerciseEntries.length && restEntries.length) {
                    restEntries.forEach((restItem, rIdx) => pushRest(restItem, `group_${block.id}_${rIdx}`));
                    return;
                }

                const maxSets = Math.max(...exerciseEntries.map(ex => parseInt(ex.target_sets || ex.sets || 1)));
                const groupInfo = groupMeta.has(block.id)
                    ? groupMeta.get(block.id)
                    : { name: 'Grupo', note: '' };
                const hasTrailingRest = entries.length > 0 && isRestItem(entries[entries.length - 1]);

                for (let s = 1; s <= maxSets; s++) {
                    entries.forEach((entry, entryIdx) => {
                        if (isRestItem(entry)) {
                            pushRest(entry, `group_${block.id}_${entryIdx}_${s}`);
                            return;
                        }
                        if (!isExerciseItem(entry)) return;
                        const exSets = parseInt(entry.target_sets || entry.sets || 1);
                        if (s <= exSets) {
                            pushWorkStep(entry, `group_${block.id}_${entryIdx}`, s, exSets, groupInfo);
                        }
                    });

                    if (s < maxSets && !hasTrailingRest) {
                        const lastExercise = exerciseEntries[exerciseEntries.length - 1];
                        const restTime = parseInt(getRestSeconds(lastExercise));
                        queue.push({
                            type: 'rest',
                            duration: restTime,
                            label: groupInfo && groupInfo.name ? `Descansar (${groupInfo.name})` : 'Descansar'
                        });
                    }
                }
            });
        }

        return queue;
    };

    const WorkoutContext = createContext();

    const WorkoutProvider = ({ children, routine }) => {
        const [queue, setQueue] = useState([]);
        const [cursor, setCursor] = useState(0); // Index in Queue
        const [status, setStatus] = useState('LOADING'); // LOADING | IDLE | WORK | REST | FINISHED
        const [sessionLog, setSessionLog] = useState([]);
        const [exerciseLookup, setExerciseLookup] = useState({});
        const [isPaused, setIsPaused] = useState(false);
        const [message, setMessage] = useState(null);
        const [confirmModal, setConfirmModal] = useState({ isOpen: false, title: "", message: "", onConfirm: null, type: "danger" }); // type: danger | warning | info


        // Timers
        const [globalTime, setGlobalTime] = useState(0);
        const [stepTimer, setStepTimer] = useState(0); // For Rest or Time-based work
        const [isTimerRunning, setIsTimerRunning] = useState(false);

        // Refs for Interval
        const stepIntervalRef = useRef(null);
        const resumeTimerRef = useRef(false);
        const onConfirmRef = useRef(null);
        const startTimeRef = useRef(Date.now()); // Track start time of current step


        // INITIALIZE
        useEffect(() => {
            if (routine) {
                const q = buildQueue(routine);
                setQueue(q);
                setStatus('IDLE');
                console.log("Queue Built:", q);
            }
        }, [routine]);

        // Reset start time when step changes
        useEffect(() => {
            startTimeRef.current = Date.now();
        }, [cursor]); // Reset on cursor change

        useEffect(() => {
            let isMounted = true;
            const loadExercises = async () => {
                try {
                    const res = await fetch("/api/exercises");
                    if (!res.ok) return;
                    const data = await res.json();
                    if (!isMounted || !Array.isArray(data)) return;
                    const lookup = data.reduce((acc, ex) => {
                        if (ex && ex._id) acc[ex._id] = ex;
                        return acc;
                    }, {});
                    setExerciseLookup(lookup);
                } catch (e) { console.error("Error loading exercises", e); }
            };

            const loadBodyParts = async () => {
                try {
                    const res = await fetch("/workout/api/body-parts");
                    const parts = await res.json();
                    parts.forEach(p => {
                        BODY_PART_MAP[p.key] = p.label_es || p.label_en || p.key;
                    });
                    // Trigger re-render if needed? 
                    // Since BODY_PART_MAP is external, components using translateBodyPart during render might need a forceUpdate, 
                    // but usually this loads fast specificly. UseState would be better but requires passing map everywhere.
                    // For MVP let's force a re-render by setting a dummy state or relying on exercise load which happens parallel.
                    setExerciseLookup(prev => ({ ...prev }));
                } catch (e) { console.error("Error loading body parts", e); }
            };

            loadExercises();
            loadBodyParts();

            return () => { isMounted = false; };
        }, []);

        // Wake Lock Implementation
        useEffect(() => {
            let wakeLock = null;

            async function requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Pantalla activa: Wake Lock adquirido');

                        wakeLock.addEventListener('release', () => {
                            console.log('Pantalla normal: Wake Lock liberado');
                        });
                    } else {
                        console.warn('Este navegador no soporta Wake Lock API');
                    }
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                }
            }

            async function releaseWakeLock() {
                if (wakeLock !== null) {
                    await wakeLock.release();
                    wakeLock = null;
                }
            }

            const handleVisibilityChange = async () => {
                if (wakeLock !== null && document.visibilityState === 'visible') {
                    await requestWakeLock();
                }
            };

            // Initial request
            requestWakeLock();

            // Event Listener
            document.addEventListener('visibilitychange', handleVisibilityChange);

            return () => {
                releaseWakeLock();
                document.removeEventListener('visibilitychange', handleVisibilityChange);
            };
        }, []);

        // Global Timer (only when actively working or resting)
        useEffect(() => {
            if (status !== 'WORK' && status !== 'REST' || isPaused) return;
            const int = setInterval(() => setGlobalTime(t => t + 1), 1000);
            return () => clearInterval(int);
        }, [status, isPaused]);

        // Step Timer Logic (Countdown)
        useEffect(() => {
            if (isPaused) {
                clearInterval(stepIntervalRef.current);
                return;
            }
            if (isTimerRunning && stepTimer > 0) {
                stepIntervalRef.current = setInterval(() => {
                    setStepTimer(prev => {
                        if (prev <= 1) {
                            // TIMER DONE
                            playAlarm();
                            setIsTimerRunning(false);
                            completeStepTimer(); // Auto-advance logic
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            } else {
                clearInterval(stepIntervalRef.current);
            }
            return () => clearInterval(stepIntervalRef.current);
        }, [isTimerRunning, stepTimer, isPaused]);

        const playAlarm = () => {
            try {
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                getAudio().play().catch(e => console.log("Audio permission needed"));
            } catch (e) { }
        }

        const currentStep = useMemo(() => queue[cursor], [queue, cursor]);
        const nextStep = useMemo(() => queue[cursor + 1], [queue, cursor]);

        // Auto-advance logic when timer hits 0
        const completeStepTimer = () => {
            if (currentStep.type === 'rest') {
                next(); // Auto-skip rest when done
            } else {
                // For Work (Time based), we just stop and wait for user to confirm "Done"? 
                // Or auto-done? User req: "Sonar alarma y pasar al descanso o siguiente serie".
                // Let's go to 'REVIEW' state or just mark done. 
                // MVP: Mark done immediately.
                logSet({
                    time_seconds: currentStep.target.time
                }); // Auto-log targeted time
                next();
            }
        };

        const logSet = (data) => {
            const exerciseId = currentStep.exercise?.exercise_id || currentStep.exercise?._id || currentStep.exercise?.id;
            const exerciseName = currentStep.exercise?.exercise_name || currentStep.exercise?.name;
            const exerciseType = currentStep.exercise?.exercise_type || currentStep.exercise?.type;
            const resolvedTime = data.time_seconds != null
                ? data.time_seconds
                : (currentStep.isTimeBased ? currentStep.target?.time : null);
            setSessionLog(prev => [...prev, {
                stepId: currentStep.id,
                exerciseId,
                exercise_id: exerciseId,
                name: exerciseName,
                exercise_type: exerciseType,
                ...data,
                duration_seconds: (Date.now() - startTimeRef.current) / 1000, // Actual execution time
                ...(resolvedTime != null ? { time_seconds: resolvedTime } : {}),
                timestamp: new Date()
            }]);
        };

        const next = () => {
            console.log("DEBUG: Next called. Cursor:", cursor, "QueueLen:", queue.length);
            if (cursor >= queue.length - 1) {
                finishWorkout();
                return;
            }
            const nextIdx = cursor + 1;
            setCursor(nextIdx);
            setIsPaused(false);

            // Setup next step state
            const upcoming = queue[nextIdx];
            if (upcoming.type === 'rest') {
                setStatus('REST');
                setStepTimer(upcoming.duration);
                setIsTimerRunning(true);
            } else {
                // Work Step
                setStatus('WORK');
                setStepTimer(upcoming.isTimeBased ? upcoming.target.time : 0);
                setIsTimerRunning(upcoming.isTimeBased); // Start immediately if timed? User said "Sonar alarma y pasar...". Usually explicit start is safer but for flow dynamic is ok.
            }
        };

        const skipToNextWork = () => {
            console.log("DEBUG: Skip to next work. Cursor:", cursor, "QueueLen:", queue.length);
            if (cursor >= queue.length - 1) {
                finishWorkout();
                return;
            }
            let nextIdx = cursor + 1;
            while (nextIdx < queue.length && queue[nextIdx].type === 'rest') {
                nextIdx += 1;
            }
            if (nextIdx >= queue.length) {
                finishWorkout();
                return;
            }
            const upcoming = queue[nextIdx];
            setCursor(nextIdx);
            setIsPaused(false);
            setStatus('WORK');
            setStepTimer(upcoming.isTimeBased ? upcoming.target.time : 0);
            setIsTimerRunning(upcoming.isTimeBased);
        };

        const prev = () => {
            if (cursor <= 0) return;
            let idx = cursor - 1;
            while (idx >= 0 && queue[idx].type === 'rest') {
                idx -= 1;
            }
            if (idx < 0) return;
            setCursor(idx);
            setIsTimerRunning(false);
            setIsPaused(false);
            const prevStep = queue[idx];
            setStatus('WORK');
            setStepTimer(prevStep.isTimeBased ? prevStep.target.time : 0);
        };

        const skipRest = () => {
            setIsTimerRunning(false);
            setIsPaused(false);
            showMessage("Descanso omitido", "info");
            next();
        };

        const addRestTime = (seconds) => {
            setStepTimer(t => {
                if (seconds < 0 && t < 10) return t;
                const nextValue = t + seconds;
                return Math.max(0, nextValue);
            });
        };

        const finishWorkout = async () => {
            showConfirm("Finalizar Rutina", "¿Deseas guardar el entrenamiento completado?", async () => {
                setStatus('FINISHED');
                // Save logic
                try {
                    const payload = {
                        routine_id: routine.id,
                        start_time: new Date(Date.now() - globalTime * 1000).toISOString(),
                        end_time: new Date().toISOString(),
                        sets: sessionLog
                    };
                    const res = await fetch("/workout/api/session/save", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    if (res.ok) window.location.href = getReturnUrl();
                } catch (e) {
                    alert("Error saving: " + e.message);
                }
            }, "success");
        };

        const cancelWorkout = () => {
            if (status === 'IDLE') {
                window.location.href = getReturnUrl();
                return;
            }
            showConfirm("Cancelar Rutina", "¿Estás seguro de que quieres salir? Se perderá el progreso actual.", () => {
                showMessage("Rutina cancelada", "error");
                window.location.href = getReturnUrl();
            }, "danger");
        };

        const showMessage = (text, tone = "info") => {
            setMessage({ text, tone });
            setTimeout(() => setMessage(null), 3000);
        };

        const togglePause = () => {
            if (status !== 'WORK' && status !== 'REST') return;
            if (!isPaused) {
                resumeTimerRef.current = isTimerRunning;
                setIsTimerRunning(false);
                setIsPaused(true);
                return;
            }
            setIsPaused(false);
            if (resumeTimerRef.current || status === 'REST') {
                setIsTimerRunning(true);
            }
        };

        const startWorkout = () => {
            if (!queue.length) return;
            const step = queue[cursor];
            setIsPaused(false);
            if (step.type === 'rest') {
                setStatus('REST');
                setStepTimer(step.duration);
                setIsTimerRunning(true);
            } else {
                setStatus('WORK');
                setStepTimer(step.isTimeBased ? step.target.time : 0);
                setIsTimerRunning(step.isTimeBased);
            }
        };

        const showConfirm = (title, message, onConfirm, type = "danger") => {
            console.log("DEBUG: showConfirm called", { title });
            onConfirmRef.current = onConfirm;
            setConfirmModal({ isOpen: true, title, message, type });
        };

        const closeConfirm = () => {
            setConfirmModal(prev => ({ ...prev, isOpen: false }));
            // Optional: onConfirmRef.current = null; // Keep it or clear it.
        };

        const handleConfirmAction = () => {
            console.log("DEBUG: handleConfirmAction called. Has Ref?", !!onConfirmRef.current);
            if (onConfirmRef.current) {
                console.log("DEBUG: Executing onConfirm callback via REF");
                onConfirmRef.current();
            }
            closeConfirm();
        };


        const value = {
            routine,
            queue,
            cursor,
            currentStep,
            nextStep,
            status,
            globalTime,
            stepTimer,
            isTimerRunning,
            setIsTimerRunning,
            next,
            prev,
            skipToNextWork,
            skipRest,
            addRestTime,
            logSet,
            sessionLog,
            finishWorkout,
            startWorkout,
            cancelWorkout,
            exerciseLookup,
            isPaused,
            togglePause,
            message,
            showMessage,
            confirmModal,
            showConfirm,
            closeConfirm,
            handleConfirmAction
        };


        return <WorkoutContext.Provider value={value}>{children}</WorkoutContext.Provider>;
    };

    const useWorkout = () => useContext(WorkoutContext);

    const ConfirmModal = () => {
        const { confirmModal, closeConfirm, handleConfirmAction } = useWorkout();
        if (!confirmModal.isOpen) return null;

        const { title, message, type } = confirmModal;
        const colorClass = type === 'danger' ? 'text-danger' : type === 'warning' ? 'text-cyber-orange' : 'text-cyber-green';
        const btnClass = type === 'danger' ? 'btn-outline-danger' : type === 'warning' ? 'btn-outline-warning' : 'btn-outline-success';

        return (
            <div className="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-black-trans animate-slide-up" style={{ zIndex: 3000 }}>
                <div className="card bg-black border border-secondary shadow-lg p-3" style={{ maxWidth: '90%', width: '350px', borderRadius: '15px' }}>
                    <div className="card-body text-center">
                        <h4 className={`fw-bold mb-3 ${colorClass}`}>{title}</h4>
                        <p className="text-white mb-4 fs-5">{message}</p>
                        <div className="d-flex gap-3 justify-content-center">
                            <button className="btn btn-secondary flex-grow-1" onClick={closeConfirm}>Cancelar</button>
                            <button className={`btn ${btnClass} flex-grow-1 fw-bold`} onClick={handleConfirmAction}>Confirmar</button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };



    // --- UI COMPONENTS ---



    const MessageBar = () => {
        const { message } = useWorkout();
        if (!message) return null;
        const toneClass = message.tone === "error"
            ? "border-danger text-danger"
            : message.tone === "success"
                ? "border-success text-cyber-green"
                : "border-info text-info";
        return (
            <div className={`mx-3 mb-3 p-2 border rounded bg-black-trans small ${toneClass}`}>
                {message.text}
            </div>
        );
    };

    const RoutineDetails = ({ routine }) => {
        const { exerciseLookup } = useWorkout();
        // Collapsed by default: We track EXPANDED groups.
        const [expandedGroups, setExpandedGroups] = useState(new Set());

        console.log("RoutineDetails Rendering:", routine);

        if (!routine) return <div className="text-white text-center">No routine data</div>;

        const toggleGroup = (groupId) => {
            const next = new Set(expandedGroups);
            if (next.has(groupId)) {
                next.delete(groupId);
            } else {
                next.add(groupId);
            }
            setExpandedGroups(next);
        };

        const items = Array.isArray(routine.items) ? routine.items : [];
        const isRestItem = (item) => item && (item.item_type === 'rest' || (!item.exercise_id && item.rest_seconds != null));
        const isExerciseItem = (item) => item && item.item_type === 'exercise';
        const buildEntry = (item) => (isRestItem(item) ? { type: 'rest', data: item } : { type: 'exercise', data: item });
        const hasInlineGroups = items.some(item => Array.isArray(item.items));

        const displayData = hasInlineGroups
            ? (() => {
                const groups = [];
                const ungrouped = [];
                items.forEach((item, idx) => {
                    if (item.item_type === 'group' || Array.isArray(item.items)) {
                        const entries = (item.items || [])
                            .filter(entry => entry && (entry.item_type === 'exercise' || isRestItem(entry)))
                            .map(buildEntry);
                        groups.push({
                            id: item._id || item.id || `group_${idx}`,
                            name: item.name || item.group_name || "Circuito",
                            note: item.note || item.description || "",
                            entries
                        });
                        return;
                    }
                    if (isExerciseItem(item) || isRestItem(item)) {
                        ungrouped.push(buildEntry(item));
                    }
                });
                return { groups, ungrouped };
            })()
            : (() => {
                const groups = items.filter(item => item.item_type === 'group');
                const groupMap = new Map();
                groups.forEach(group => {
                    groupMap.set(group._id, {
                        id: group._id,
                        name: group.group_name || "Grupo",
                        note: group.note || group.description || "",
                        entries: []
                    });
                });
                const ungrouped = [];
                items.forEach(item => {
                    if (item.item_type === 'group') return;
                    if (!isExerciseItem(item) && !isRestItem(item)) return;
                    if (item.group_id && groupMap.has(item.group_id)) {
                        groupMap.get(item.group_id).entries.push(buildEntry(item));
                    } else {
                        ungrouped.push(buildEntry(item));
                    }
                });
                return { groups: Array.from(groupMap.values()).filter(group => group.entries.length), ungrouped };
            })();

        const totalExercises = displayData.groups.reduce((acc, group) => acc + group.entries.filter(entry => entry.type === 'exercise').length, 0)
            + displayData.ungrouped.filter(entry => entry.type === 'exercise').length;

        const renderEntry = (entry, key) => {
            if (entry.type === 'rest') {
                const restSeconds = getRestSeconds(entry.data);
                const restLabel = entry.data.note || "Descanso";
                return (
                    <div key={key} className="d-flex justify-content-between align-items-center border border-secondary rounded px-2 py-2 bg-black-trans">
                        <div>
                            <div className="text-white fw-bold">{restLabel}</div>
                            <div className="text-secondary small">Pausa</div>
                        </div>
                        <div className="text-end text-secondary small">
                            <div>{restSeconds}s</div>
                        </div>
                    </div>
                );
            }

            const ex = entry.data || {};
            const isTime = (ex.exercise_type || ex.type) === 'time' || (ex.exercise_type || ex.type) === 'cardio';
            const name = ex.exercise_name || ex.name || "Ejercicio";
            const bodyPartLabel = translateBodyPart(ex.body_part);
            const equipmentMeta = getEquipmentMeta(ex.equipment);
            const hasVideo = ex.video_url && ex.video_url.trim() !== "";
            const substitutes = resolveSubstitutes(ex.substitutes || [], exerciseLookup);
            const subsId = `subs_${key}`;
            const sets = ex.target_sets || ex.sets || 1;
            const reps = ex.target_reps || ex.reps;
            const time = ex.target_time_seconds || ex.time_seconds;
            const rest = getRestSeconds(ex);
            return (
                <div key={key} className="d-flex justify-content-between align-items-start gap-3">
                    <div>
                        <div className="d-flex align-items-center gap-2">
                            <div className="text-white fw-bold">{name}</div>
                            {hasVideo && (
                                <button
                                    type="button"
                                    className="btn btn-sm btn-outline-danger"
                                    title="Ver video"
                                    onClick={() => openVideoModal(ex.video_url)}
                                >
                                    <i className="fab fa-youtube"></i>
                                </button>
                            )}
                        </div>
                        <div className="text-secondary small d-flex flex-wrap gap-2 mt-1">
                            <span className="badge bg-secondary">{bodyPartLabel}</span>
                            <span className="badge bg-dark border border-secondary text-info">
                                <i className={`${equipmentMeta.icon} me-1`}></i>{equipmentMeta.label}
                            </span>
                        </div>
                        {(ex.comment || ex.note) && (
                            <div className="mt-2 text-warning small fst-italic">
                                <i className="fas fa-sticky-note me-1"></i> {ex.comment || ex.note}
                            </div>
                        )}
                        {substitutes.length > 0 && (
                            <div className="mt-2">
                                <button
                                    className="btn btn-sm btn-outline-info"
                                    type="button"
                                    data-bs-toggle="collapse"
                                    data-bs-target={`#${subsId}`}
                                    aria-expanded="false"
                                    aria-controls={subsId}
                                >
                                    Sustitutos ({substitutes.length})
                                </button>
                                <div className="collapse mt-2" id={subsId}>
                                    <div className="d-flex flex-column gap-2">
                                        {substitutes.map((sub, sIdx) => {
                                            const subEquipment = getEquipmentMeta(sub.equipment);
                                            const subHasVideo = sub.video_url && sub.video_url.trim() !== "";
                                            return (
                                                <div key={`${key}_sub_${sIdx}`} className="d-flex align-items-center justify-content-between border border-secondary rounded px-2 py-2">
                                                    <div>
                                                        <div className="fw-bold text-white">{sub.name || "Ejercicio"}</div>
                                                        <div className="small text-secondary">
                                                            <i className={`${subEquipment.icon} me-1`}></i>{subEquipment.label}
                                                        </div>
                                                    </div>
                                                    {subHasVideo && (
                                                        <button
                                                            type="button"
                                                            className="btn btn-sm btn-outline-danger ms-2"
                                                            title="Ver video"
                                                            onClick={() => openVideoModal(sub.video_url)}
                                                        >
                                                            <i className="fab fa-youtube"></i>
                                                        </button>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="text-end text-secondary small">
                        <div>{sets} sets {isTime ? `x ${time || 60}s` : `x ${reps || '-'}`}</div>
                        <div>Descanso {rest || 60}s</div>
                    </div>
                </div>
            );
        };

        return (
            <div className="card mx-3" style={{ background: 'rgba(30,30,30,0.95)', border: '1px solid #444', borderRadius: '20px', minHeight: '300px', opacity: 1 }}>
                <div className="card-body">
                    <div className="text-center mb-4">
                        <h2 className="display-6 fw-bold text-white mb-2">{routine.name || "Rutina"}</h2>
                        <p className="text-secondary m-0">{totalExercises} ejercicios -  Revisa los detalles antes de iniciar</p>
                    </div>

                    <div className="d-flex flex-column gap-3 overflow-auto custom-scroll" style={{ maxHeight: '60vh' }}>
                        {displayData.groups.map((group, idx) => {
                            const isExpanded = expandedGroups.has(group.id);
                            return (
                                <div key={`routine_group_${idx}`} className="p-3 border border-secondary rounded-3 bg-black-trans">
                                    <div
                                        className="d-flex justify-content-between align-items-center cursor-pointer"
                                        onClick={() => toggleGroup(group.id)}
                                    >
                                        <div>
                                            <div className="text-cyber-orange text-uppercase small fw-bold">
                                                {group.name || "Circuito"} ({group.entries.length} items)
                                            </div>
                                            {group.note && <div className="text-white small mt-1 fst-italic">"{group.note}"</div>}
                                        </div>
                                        <i className={`fas fa-chevron-down text-secondary transition-icon ${isExpanded ? 'rotate-180' : ''}`}></i>
                                    </div>

                                    {isExpanded && (
                                        <div className="d-flex flex-column gap-2 mt-3 animate-fade-in">
                                            {group.entries.map((entry, entryIdx) => (
                                                renderEntry(entry, `group_${idx}_${entryIdx}`)
                                            ))}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                        {displayData.ungrouped.length > 0 && (
                            <div className="p-3 border border-secondary rounded-3 bg-black-trans">
                                <div className="d-flex flex-column gap-2">
                                    {displayData.ungrouped.map((entry, entryIdx) => (
                                        renderEntry(entry, `ungrouped_${entryIdx}`)
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    };

    const PreStart = () => {
        const { routine, startWorkout } = useWorkout();
        return (
            <div className="player-container">
                <Header />
                <div className="visual-stage text-center">
                    <RoutineDetails routine={routine} />
                </div>
                <div className="controls-section">
                    <button className="btn btn-action shadow-lg ripple" onClick={startWorkout}>
                        INICIAR ENTRENAMIENTO <i className="fas fa-play ms-2"></i>
                    </button>
                </div>
            </div>
        );
    };

    const InputControls = ({ step }) => {
        const { logSet, next, sessionLog } = useWorkout();
        // Local state for inputs so we can edit before committing
        const [weight, setWeight] = useState(step.target.weight || '');
        const [reps, setReps] = useState(step.target.reps || '');
        const [rpe, setRpe] = useState(8);
        const [unit, setUnit] = useState('lb');
        const weightInputRef = useRef(null);

        // Pre-fill from history and AUTO-FOCUS
        useEffect(() => {
            const exerciseId = step.exercise?.exercise_id || step.exercise?._id || step.exercise?.id;
            let nextWeight = step.target.weight || '';
            let nextReps = step.target.reps || '';
            if (exerciseId) {
                const lastMatch = [...sessionLog].reverse().find(entry => entry.exerciseId === exerciseId);
                if (lastMatch) {
                    if (nextWeight === '' && lastMatch.weight) nextWeight = lastMatch.weight;
                    if (lastMatch.reps) nextReps = lastMatch.reps;
                }
            }
            if (unit === 'lb' && nextWeight !== '') {
                // Convert KG (from DB) to LB
                const valKg = parseFloat(nextWeight);
                if (!isNaN(valKg)) {
                    nextWeight = (valKg * 2.20462).toFixed(1);
                }
            }

            setWeight(nextWeight);
            setReps(nextReps);
            setRpe(8);

            // Auto-focus logic
            if (weightInputRef.current) {
                // Small timeout to ensure DOM is ready and transition is done
                setTimeout(() => {
                    weightInputRef.current.focus();
                    weightInputRef.current.select();
                }, 100);
            }
        }, [step, sessionLog]);

        const adjustReps = (delta) => {
            const current = parseInt(reps, 10);
            const base = Number.isFinite(current) ? current : 0;
            const nextValue = Math.max(0, base + delta);
            setReps(String(nextValue));
        };

        const handleSubmit = () => {
            let finalWeight = parseFloat(weight) || 0;
            if (unit === 'lb') {
                finalWeight = finalWeight / 2.20462;
            }
            logSet({ weight: finalWeight.toFixed(1), reps, rpe });
            next();
        };

        // Expose submit handler via Ref if we were using a parent generic button, 
        // but cleaner to have the main button Context-aware or passed down. 
        // We'll use a specific ID based approach or shared state if needed.
        // BETTER: The MainButton is smart. It detects "Type". 



        const toggleUnit = () => {
            setUnit(prev => prev === 'kg' ? 'lb' : 'kg');
            const val = parseFloat(weight) || 0;
            if (val > 0) {
                if (unit === 'kg') {
                    setWeight((val * 2.20462).toFixed(1));
                } else {
                    setWeight((val / 2.20462).toFixed(1));
                }
            }
        };

        const adjustWeight = (delta) => {
            let val = parseFloat(weight) || 0;
            const newVal = Math.max(0, val + delta);
            setWeight(newVal.toFixed(1));
        };

        const equivalentText = React.useMemo(() => {
            const val = parseFloat(weight) || 0;
            if (unit === 'kg') {
                return `≈ ${(val * 2.20462).toFixed(1)} lb`;
            } else {
                return `≈ ${(val / 2.20462).toFixed(1)} kg`;
            }
        }, [weight, unit]);

        return (
            <div className="py-2">
                <div className="row g-2 justify-content-center mb-3 mb-md-4">
                    <div className="col-12 col-md-6">
                        <div className="d-flex align-items-center justify-content-center mb-2 gap-2">
                            <label className="text-secondary small fw-bold m-0">PESO</label>
                            <button className="btn btn-sm btn-dark border border-secondary py-0 px-2 small font-monospace" onClick={toggleUnit}>
                                {unit.toUpperCase()} <i className="fas fa-sync-alt ms-1 text-muted" style={{ fontSize: '0.7em' }}></i>
                            </button>
                        </div>
                        <div className="d-flex align-items-center justify-content-center gap-2">
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustWeight(unit === 'lb' ? -5 : -2.5)}
                            >-</button>
                            <div className="position-relative">
                                <input type="text"
                                    ref={weightInputRef}
                                    className="form-control input-hud text-center"
                                    style={{ maxWidth: '120px' }}
                                    value={weight}
                                    onChange={e => setWeight(e.target.value)}
                                    placeholder="0"
                                    inputMode="decimal"
                                    onClick={(e) => e.target.select()}
                                />
                                <div className="position-absolute start-50 translate-middle-x text-muted small" style={{ bottom: '-20px', fontSize: '0.75rem', whiteSpace: 'nowrap' }}>
                                    {equivalentText}
                                </div>
                            </div>
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustWeight(unit === 'lb' ? 5 : 2.5)}
                            >+</button>
                        </div>
                    </div>
                    <div className="col-12 col-md-6">
                        <label className="text-secondary small fw-bold mb-2 d-block text-center">
                            REPS {step.target.reps && <span className="text-cyber-green ms-2">(Meta: {step.target.reps})</span>}
                        </label>
                        <div className="d-flex align-items-center justify-content-center gap-2">
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustReps(-1)}
                            >-</button>
                            <input
                                type="text"
                                className="form-control input-hud"
                                style={{ maxWidth: '120px' }}
                                value={reps}
                                onChange={e => setReps(e.target.value)}
                                placeholder="0"
                                inputMode="numeric"
                                pattern="[0-9\\-]*"
                                onClick={(e) => e.target.select()}
                            />
                            <button
                                className="btn btn-outline-secondary btn-control-hud d-flex align-items-center justify-content-center"
                                type="button"
                                onClick={() => adjustReps(1)}
                            >+</button>
                        </div>
                    </div>
                </div>

                <div className="mb-3 mb-md-4">
                    <label className="text-secondary small fw-bold mb-2 d-block text-center">RPE (Esfuerzo 1-10)</label>
                    <div className="d-flex justify-content-center gap-2">
                        {[7, 8, 9, 10].map(val => (
                            <button key={val}
                                className={`btn btn-sm btn-rpe-hud d-flex align-items-center justify-content-center ${rpe === val ? 'btn-light' : 'btn-outline-secondary'}`}
                                onClick={() => setRpe(val)}
                            >{val}</button>
                        ))}
                    </div>
                </div>

                <button className="btn btn-action shadow-lg ripple" onClick={handleSubmit}>
                    COMPLETAR SERIE <i className="fas fa-check ms-2"></i>
                </button>
            </div>
        );
    };

    const TimerControls = ({ step }) => {
        const { stepTimer, isTimerRunning, setIsTimerRunning, next, logSet } = useWorkout();

        const toggle = () => setIsTimerRunning(!isTimerRunning);
        const finish = () => {
            logSet({
                time_seconds: step.target.time
            });
            next();
        }

        return (
            <div className="text-center py-4">
                <div className="display-1 fw-bold text-white mb-2 font-monospace" style={{ textShadow: '0 0 20px rgba(255,255,255,0.2)' }}>
                    {formatTime(stepTimer)}
                </div>
                <p className="text-cyber-green mb-4">TIEMPO OBJETIVO</p>

                <div className="d-grid gap-2">
                    {!isTimerRunning && stepTimer > 0 && (
                        <button className="btn btn-action" onClick={toggle}>INICIAR <i className="fas fa-play ms-2"></i></button>
                    )}
                    {isTimerRunning && (
                        <button className="btn btn-outline-light py-3 border-2" onClick={toggle}>PAUSA ||</button>
                    )}
                    <button className="btn btn-outline-secondary btn-sm mt-3" onClick={finish}>Terminar Manualmente</button>
                </div>
            </div>
        );
    };

    const RestOverlay = ({ nextStep }) => {
        const { currentStep, skipRest, stepTimer } = useWorkout();

        if (currentStep.type !== 'rest') return null;

        const nextExName = nextStep?.exercise?.name || nextStep?.exercise?.exercise_name || "Siguiente Ejercicio";
        // Check for comment/note/description
        const nextNote = nextStep?.exercise?.comment || nextStep?.exercise?.note || nextStep?.exercise?.description || "";
        const isNextTimeBased = nextStep?.isTimeBased || false; // Or check type

        return (
            <div className="rest-overlay position-fixed top-0 start-0 w-100 h-100 d-flex flex-column justify-content-center align-items-center bg-dark text-white p-4" style={{ zIndex: 2000 }}>
                <div className="text-center mb-5">
                    <h2 className="display-1 fw-bold mb-0 text-cyber-green font-monospace">{formatTime(stepTimer)}</h2>
                    <p className="text-secondary text-uppercase letter-spacing-2 mt-2">Descanso</p>
                </div>

                <div className="text-center mb-5 animate-pulse">
                    <p className="text-muted small mb-2 text-uppercase">A continuación</p>
                    <h3 className="h2 fw-bold mb-3">{nextExName}</h3>
                    {nextNote && (
                        <div className="alert alert-dark border-secondary text-info d-inline-block px-4 py-2" style={{ maxWidth: '90%' }}>
                            <i className="fas fa-info-circle me-2"></i>{nextNote}
                        </div>
                    )}
                </div>

                <button className="btn btn-outline-light rounded-pill px-5 py-3" onClick={skipRest}>
                    SALTAR DESCANSO <i className="fas fa-forward ms-2"></i>
                </button>
            </div>
        );
    };

    const ActiveExercise = () => {
        const { currentStep } = useWorkout();

        if (!currentStep || currentStep.type !== 'work' || !currentStep.exercise) return null;
        const ex = currentStep.exercise || {};
        const name = ex.exercise_name || ex.name || 'Ejercicio';
        const bodyPart = translateBodyPart(ex.body_part);
        const hasVideo = ex.video_url && ex.video_url.trim() !== "";
        const exerciseComment = ex.comment || ex.note || ex.description || "";
        const groupComment = currentStep.groupComment || "";

        return (
            <div className={`active-card ${currentStep.isTimeBased ? 'time-mode' : ''} animate-entry`}>
                <div className="d-flex flex-column justify-content-center h-100">

                    {currentStep.groupName && (
                        <div className="text-center mb-3">
                            <span className="badge bg-danger px-3 py-2">{currentStep.groupName}</span>
                        </div>
                    )}

                    <div className="text-center mb-4">
                        <span className="text-secondary text-uppercase small tracking-widest">{bodyPart}</span>
                        <div className="d-flex flex-column align-items-center justify-content-center gap-2 mt-1">
                            <h2 className="display-6 fw-bold text-white m-0 heading-wrap">{name}</h2>
                            {hasVideo && (
                                <button
                                    type="button"
                                    className="btn btn-sm btn-outline-danger rounded-pill px-3 py-1"
                                    style={{ fontSize: '0.8rem' }}
                                    onClick={() => openVideoModal(ex.video_url)}
                                >
                                    <i className="fab fa-youtube me-2"></i> Ver Tutorial
                                </button>
                            )}
                        </div>
                        <div className="mt-2 text-info fs-5">
                            Serie <span className="text-white fw-bold">{currentStep.setNumber}</span> / <span className="text-secondary">{currentStep.totalSets}</span>
                        </div>
                    </div>

                    <div className="mt-2">
                        {currentStep.isTimeBased ? (
                            <TimerControls step={currentStep} />
                        ) : (
                            <InputControls step={currentStep} />
                        )}
                    </div>

                    {(groupComment || exerciseComment) && (
                        <div className="mt-3 pt-3 border-top border-secondary text-center">
                            {groupComment && <div className="text-cyber-orange small">{groupComment}</div>}
                            {exerciseComment && <div className="text-secondary small">{exerciseComment}</div>}
                        </div>
                    )}
                </div>
            </div>
        );
    };



    const NextUpBar = () => {
        const { queue, cursor, status } = useWorkout();
        if (status === 'LOADING' || status === 'IDLE' || status === 'FINISHED') return null;

        let idx = cursor + 1;
        while (idx < queue.length && queue[idx].type !== 'work') {
            idx += 1;
        }
        if (idx >= queue.length) return null;

        let restInfo = "";
        const restIdx = cursor + 1;
        if (restIdx < queue.length && queue[restIdx].type === 'rest') {
            const restStep = queue[restIdx];
            restInfo = `${restStep.duration || 0}s`;
        }

        const ex = queue[idx].exercise || {};
        const name = ex.exercise_name || ex.name || "Ejercicio";
        return (
            <div className="px-3 pb-2 text-center w-100">
                <div className="d-inline-flex align-items-center justify-content-center gap-2 py-1 px-3 rounded-pill bg-black-trans border border-dark" style={{ opacity: 0.7, maxWidth: '95%' }}>
                    <span className="text-secondary text-uppercase flex-shrink-0" style={{ fontSize: '0.7rem', letterSpacing: '1px' }}>Siguiente</span>
                    <span className="text-light fw-bold text-truncate" style={{ fontSize: '0.8rem', maxWidth: '60vw' }}>{name}</span>
                    {restInfo && <span className="text-muted flex-shrink-0" style={{ fontSize: '0.7rem' }}>({restInfo})</span>}
                </div>
            </div>
        );
    };

    const Header = () => {
        const { routine, globalTime, cursor, queue, isPaused, togglePause, cancelWorkout, status, startWorkout } = useWorkout();

        // Calculate Work Steps only
        const workStats = React.useMemo(() => {
            const total = queue.filter(s => s.type === 'work').length;
            // Include current if it is work, or count up to this point
            const passed = queue.slice(0, cursor + 1).filter(s => s.type === 'work').length;
            return { passed, total };
        }, [cursor, queue]);

        return (
            <div className="header-section d-flex justify-content-between align-items-center p-3 relative">
                {/* Left: Info */}
                <div style={{ flex: 1 }}>
                    <h5 className="m-0 fw-bold text-white text-truncate" style={{ fontSize: '1rem' }}>{routine.name}</h5>
                    <div className="text-secondary small text-truncate">
                        Serie {workStats.passed} / {workStats.total}
                    </div>
                </div>

                {/* Center: Global Timer */}
                <div className="position-absolute start-50 top-50 translate-middle">
                    <div className="font-monospace fs-3 text-cyber-green fw-bold bg-black px-3 rounded-pill border border-secondary shadow-sm">
                        {formatTime(globalTime)}
                    </div>
                </div>

                {/* Right: Controls */}
                <div className="d-flex align-items-center gap-2" style={{ flex: 1, justifyContent: 'flex-end' }}>
                    {status === 'IDLE' ? (
                        <button className="btn btn-sm btn-outline-success rounded-pill px-3" onClick={startWorkout}>
                            <i className="fas fa-play"></i>
                        </button>
                    ) : (
                        <button className="btn btn-sm btn-outline-light rounded-pill px-3" onClick={togglePause}>
                            <i className={`fas ${isPaused ? 'fa-play' : 'fa-pause'}`}></i>
                        </button>
                    )}
                    <button className="btn btn-sm btn-outline-danger rounded-circle" onClick={cancelWorkout} style={{ width: '32px', height: '32px', padding: 0 }}>
                        <i className="fas fa-times"></i>
                    </button>
                </div>
            </div>
        );
    };

    const NavigationWrapper = ({ children }) => {
        const { prev, skipToNextWork, showMessage, showConfirm } = useWorkout();

        const handleSkip = () => {
            showConfirm("Saltar Serie", "¿Seguro que quieres omitir esta serie?", () => {
                showMessage("Set omitido", "info");
                skipToNextWork();
            }, "warning");
        };

        return (
            <div className="d-flex w-100 h-100 align-items-center justify-content-center position-relative">

                {/* Desktop Prev (Left) */}
                <div className="d-none d-md-block me-3">
                    <button className="btn btn-outline-secondary rounded-circle p-3" onClick={prev} style={{ width: '60px', height: '60px' }}>
                        <i className="fas fa-chevron-left fa-lg"></i>
                    </button>
                </div>

                {/* Main Content */}
                <div className="flex-grow-1 d-flex flex-column align-items-center justify-content-center w-100" style={{ maxWidth: '600px' }}>
                    {children}

                    {/* Mobile Navigation (Bottom of Card) */}
                    <div className="d-flex d-md-none w-100 justify-content-between px-3 mt-3">
                        <button className="btn btn-link text-secondary text-decoration-none" onClick={prev}>
                            <i className="fas fa-chevron-left me-1"></i> Anterior
                        </button>
                        <button className="btn btn-link text-secondary text-decoration-none" onClick={handleSkip}>
                            Saltar <i className="fas fa-chevron-right ms-1"></i>
                        </button>
                    </div>
                </div>

                {/* Desktop Skip (Right) */}
                <div className="d-none d-md-block ms-3">
                    <button className="btn btn-outline-secondary rounded-circle p-3" onClick={handleSkip} style={{ width: '60px', height: '60px' }}>
                        <i className="fas fa-chevron-right fa-lg"></i>
                    </button>
                </div>
            </div>
        );
    };

    // --- MAIN APP ---
    const App = () => {
        const { currentStep, status, queue, cursor } = useWorkout();

        // Calculate next work step for preview
        const nextStep = React.useMemo(() => {
            if (!queue || cursor >= queue.length - 1) return null;
            // Find next WORK step
            return queue.slice(cursor + 1).find(s => s.type === 'work');
        }, [queue, cursor]);

        console.log("App Status:", status);
        console.log("App Routine:", window.initialRoutine);

        if (status === 'LOADING') return <div className="text-center text-white py-5">Cargando Motor...</div>;
        if (status === 'IDLE') return <PreStart />;
        if (status === 'FINISHED') return <div className="d-flex flex-column h-100 justify-content-center align-items-center text-success"><h1>¡Entrenamiento Completado!</h1><p>Guardando...</p></div>;

        return (
            <div className="player-container">
                <Header />

                <div className="visual-stage">
                    <MessageBar />
                    <NextUpBar />
                    <NavigationWrapper>
                        {currentStep && <ActiveExercise />}
                    </NavigationWrapper>
                </div>

                <RestOverlay nextStep={nextStep} />
                <ConfirmModal />
            </div>
        );
    };

    const Root = () => (
        <WorkoutProvider routine={INITIAL_ROUTINE}>
            <App />
        </WorkoutProvider>
    );

    // Mount
    const root = ReactDOM.createRoot(document.getElementById('react-root'));
    root.render(<Root />);
</script>
{% endraw %}
{% endblock %}